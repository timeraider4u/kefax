/*
 * generated by Xtext
 */
package at.jku.isse.ecco.kefax.kbuild.serializer;

import at.jku.isse.ecco.kefax.kbuild.kbuild.BuildEntry;
import at.jku.isse.ecco.kefax.kbuild.kbuild.Entry;
import at.jku.isse.ecco.kefax.kbuild.kbuild.HostProgram;
import at.jku.isse.ecco.kefax.kbuild.kbuild.If;
import at.jku.isse.ecco.kefax.kbuild.kbuild.IfEq;
import at.jku.isse.ecco.kefax.kbuild.kbuild.IfNEq;
import at.jku.isse.ecco.kefax.kbuild.kbuild.Ifndef;
import at.jku.isse.ecco.kefax.kbuild.kbuild.Include;
import at.jku.isse.ecco.kefax.kbuild.kbuild.KbuildPackage;
import at.jku.isse.ecco.kefax.kbuild.kbuild.Model;
import at.jku.isse.ecco.kefax.kbuild.kbuild.MyVariable;
import at.jku.isse.ecco.kefax.kbuild.kbuild.Obj_m;
import at.jku.isse.ecco.kefax.kbuild.kbuild.Obj_y;
import at.jku.isse.ecco.kefax.kbuild.kbuild.ObjectDir;
import at.jku.isse.ecco.kefax.kbuild.kbuild.ObjectFile;
import at.jku.isse.ecco.kefax.kbuild.kbuild.ObjectShellChar;
import at.jku.isse.ecco.kefax.kbuild.kbuild.ObjectShellCmd;
import at.jku.isse.ecco.kefax.kbuild.kbuild.ObjectSingleFile;
import at.jku.isse.ecco.kefax.kbuild.kbuild.ObjectString;
import at.jku.isse.ecco.kefax.kbuild.kbuild.ObjectVariable;
import at.jku.isse.ecco.kefax.kbuild.kbuild.ShellCmd;
import at.jku.isse.ecco.kefax.kbuild.kbuild.ShellPart;
import at.jku.isse.ecco.kefax.kbuild.kbuild.Target;
import at.jku.isse.ecco.kefax.kbuild.kbuild.Values;
import at.jku.isse.ecco.kefax.kbuild.kbuild.VarSlashSym;
import at.jku.isse.ecco.kefax.kbuild.kbuild.Variable;
import at.jku.isse.ecco.kefax.kbuild.services.KbuildGrammarAccess;
import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class KbuildSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private KbuildGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == KbuildPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case KbuildPackage.BUILD_ENTRY:
				sequence_BuildEntry(context, (BuildEntry) semanticObject); 
				return; 
			case KbuildPackage.ENTRY:
				sequence_Entry(context, (Entry) semanticObject); 
				return; 
			case KbuildPackage.HOST_PROGRAM:
				sequence_BuildEntry(context, (HostProgram) semanticObject); 
				return; 
			case KbuildPackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case KbuildPackage.IF_EQ:
				sequence_BuildEntry(context, (IfEq) semanticObject); 
				return; 
			case KbuildPackage.IF_NEQ:
				sequence_BuildEntry(context, (IfNEq) semanticObject); 
				return; 
			case KbuildPackage.IFNDEF:
				sequence_BuildEntry(context, (Ifndef) semanticObject); 
				return; 
			case KbuildPackage.INCLUDE:
				sequence_ShellCmd(context, (Include) semanticObject); 
				return; 
			case KbuildPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case KbuildPackage.MY_VARIABLE:
				sequence_BuildEntry(context, (MyVariable) semanticObject); 
				return; 
			case KbuildPackage.OBJ_M:
				sequence_Object_M(context, (Obj_m) semanticObject); 
				return; 
			case KbuildPackage.OBJ_Y:
				sequence_Object_Y(context, (Obj_y) semanticObject); 
				return; 
			case KbuildPackage.OBJECT:
				sequence_BuildEntry(context, (at.jku.isse.ecco.kefax.kbuild.kbuild.Object) semanticObject); 
				return; 
			case KbuildPackage.OBJECT_DIR:
				sequence_Value(context, (ObjectDir) semanticObject); 
				return; 
			case KbuildPackage.OBJECT_FILE:
				sequence_Value(context, (ObjectFile) semanticObject); 
				return; 
			case KbuildPackage.OBJECT_SHELL_CHAR:
				sequence_Value(context, (ObjectShellChar) semanticObject); 
				return; 
			case KbuildPackage.OBJECT_SHELL_CMD:
				sequence_Value(context, (ObjectShellCmd) semanticObject); 
				return; 
			case KbuildPackage.OBJECT_SINGLE_FILE:
				sequence_Value(context, (ObjectSingleFile) semanticObject); 
				return; 
			case KbuildPackage.OBJECT_STRING:
				sequence_Value(context, (ObjectString) semanticObject); 
				return; 
			case KbuildPackage.OBJECT_VARIABLE:
				sequence_Value(context, (ObjectVariable) semanticObject); 
				return; 
			case KbuildPackage.SHELL_CMD:
				sequence_ShellCmd(context, (ShellCmd) semanticObject); 
				return; 
			case KbuildPackage.SHELL_PART:
				sequence_ShellPart(context, (ShellPart) semanticObject); 
				return; 
			case KbuildPackage.TARGET:
				sequence_BuildEntry(context, (Target) semanticObject); 
				return; 
			case KbuildPackage.VALUES:
				sequence_Values(context, (Values) semanticObject); 
				return; 
			case KbuildPackage.VAR_SLASH_SYM:
				sequence_VarSlashSym(context, (VarSlashSym) semanticObject); 
				return; 
			case KbuildPackage.VARIABLE:
				if(context == grammarAccess.getIfRule()) {
					sequence_If_Variable(context, (Variable) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getVarSlashSymRule() ||
				   context == grammarAccess.getVariableRule()) {
					sequence_Variable(context, (Variable) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     value=Entry
	 */
	protected void sequence_BuildEntry(EObject context, BuildEntry semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KbuildPackage.Literals.BUILD_ENTRY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KbuildPackage.Literals.BUILD_ENTRY__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBuildEntryAccess().getValueEntryParserRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=SYMBOL variable=Variable? value=AssignExtra inner=Assign?)
	 */
	protected void sequence_BuildEntry(EObject context, HostProgram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=If
	 */
	protected void sequence_BuildEntry(EObject context, IfEq semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KbuildPackage.Literals.BUILD_ENTRY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KbuildPackage.Literals.BUILD_ENTRY__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBuildEntryAccess().getValueIfParserRuleCall_1_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=If
	 */
	protected void sequence_BuildEntry(EObject context, IfNEq semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KbuildPackage.Literals.BUILD_ENTRY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KbuildPackage.Literals.BUILD_ENTRY__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBuildEntryAccess().getValueIfParserRuleCall_2_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=SYMBOL (value=Object_Y | value=Object_M))
	 */
	protected void sequence_BuildEntry(EObject context, Ifndef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=SYMBOL variable=Variable? value=Assign)
	 */
	protected void sequence_BuildEntry(EObject context, MyVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=Object_Y | value=Object_M)
	 */
	protected void sequence_BuildEntry(EObject context, at.jku.isse.ecco.kefax.kbuild.kbuild.Object semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (target=Values (values+=Values values+=Values*)?)
	 */
	protected void sequence_BuildEntry(EObject context, Target semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (variable=Variable value=AssignExtra)
	 */
	protected void sequence_Entry(EObject context, Entry semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KbuildPackage.Literals.ENTRY__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KbuildPackage.Literals.ENTRY__VARIABLE));
			if(transientValues.isValueTransient(semanticObject, KbuildPackage.Literals.ENTRY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KbuildPackage.Literals.ENTRY__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEntryAccess().getVariableVariableParserRuleCall_2_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getEntryAccess().getValueAssignExtraParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (shell=ShellCmd (value=Object_Y | value=Object_M | value=Entry | value=ShellCmd) (elsevalue=Object_Y | elsevalue=Object_M)?)
	 */
	protected void sequence_If(EObject context, If semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=SYMBOL (value=Object_Y | value=Object_M | value=Entry | value=ShellCmd) (elsevalue=Object_Y | elsevalue=Object_M)?)
	 */
	protected void sequence_If_Variable(EObject context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (buildEntry+=BuildEntry? buildEntry+=BuildEntry*)
	 */
	protected void sequence_Model(EObject context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=AssignExtra
	 */
	protected void sequence_Object_M(EObject context, Obj_m semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KbuildPackage.Literals.OBJ_M__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KbuildPackage.Literals.OBJ_M__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getObject_MAccess().getValueAssignExtraParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=AssignExtra
	 */
	protected void sequence_Object_Y(EObject context, Obj_y semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KbuildPackage.Literals.OBJ_Y__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KbuildPackage.Literals.OBJ_Y__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getObject_YAccess().getValueAssignExtraParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {Include}
	 */
	protected void sequence_ShellCmd(EObject context, Include semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=SYMBOL shellPart+=ShellPart+)
	 */
	protected void sequence_ShellCmd(EObject context, ShellCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((val=VarSlashSym | cmd=ShellCmd)?)
	 */
	protected void sequence_ShellPart(EObject context, ShellPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {ObjectDir}
	 */
	protected void sequence_Value(EObject context, ObjectDir semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {ObjectFile}
	 */
	protected void sequence_Value(EObject context, ObjectFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=SHELL_CHAR
	 */
	protected void sequence_Value(EObject context, ObjectShellChar semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KbuildPackage.Literals.OBJECT_SHELL_CHAR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KbuildPackage.Literals.OBJECT_SHELL_CHAR__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getValueAccess().getValueSHELL_CHARTerminalRuleCall_5_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=ShellCmd
	 */
	protected void sequence_Value(EObject context, ObjectShellCmd semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KbuildPackage.Literals.OBJECT_SHELL_CMD__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KbuildPackage.Literals.OBJECT_SHELL_CMD__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getValueAccess().getValueShellCmdParserRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=SYMBOL
	 */
	protected void sequence_Value(EObject context, ObjectSingleFile semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KbuildPackage.Literals.OBJECT_SINGLE_FILE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KbuildPackage.Literals.OBJECT_SINGLE_FILE__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getValueAccess().getNameSYMBOLTerminalRuleCall_1_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {ObjectString}
	 */
	protected void sequence_Value(EObject context, ObjectString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=Variable additional=SLASH?)
	 */
	protected void sequence_Value(EObject context, ObjectVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (values+=Value+ values+=Value*)
	 */
	protected void sequence_Values(EObject context, Values semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=SLASH | name=SYMBOL)
	 */
	protected void sequence_VarSlashSym(EObject context, VarSlashSym semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=SYMBOL
	 */
	protected void sequence_Variable(EObject context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
