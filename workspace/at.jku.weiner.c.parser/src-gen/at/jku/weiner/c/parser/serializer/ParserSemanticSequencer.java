/*
 * generated by Xtext 2.9.0-SNAPSHOT
 */
package at.jku.weiner.c.parser.serializer;

import at.jku.weiner.c.common.common.Common;
import at.jku.weiner.c.common.common.CommonPackage;
import at.jku.weiner.c.common.serializer.CommonSemanticSequencer;
import at.jku.weiner.c.parser.parser.AdditiveExpression;
import at.jku.weiner.c.parser.parser.AndExpression;
import at.jku.weiner.c.parser.parser.ArgumentExpressionList;
import at.jku.weiner.c.parser.parser.AsmLineWithColon;
import at.jku.weiner.c.parser.parser.AsmLineWithComma;
import at.jku.weiner.c.parser.parser.AsmStatement;
import at.jku.weiner.c.parser.parser.AssignmentExpression;
import at.jku.weiner.c.parser.parser.AssignmentOperator;
import at.jku.weiner.c.parser.parser.BlockList;
import at.jku.weiner.c.parser.parser.BodyStatement;
import at.jku.weiner.c.parser.parser.CastExpression;
import at.jku.weiner.c.parser.parser.CompoundStatement;
import at.jku.weiner.c.parser.parser.ConditionalExpression;
import at.jku.weiner.c.parser.parser.Constant;
import at.jku.weiner.c.parser.parser.ConstantExpression;
import at.jku.weiner.c.parser.parser.Declaration;
import at.jku.weiner.c.parser.parser.DeclarationSpecifiers;
import at.jku.weiner.c.parser.parser.Declarator;
import at.jku.weiner.c.parser.parser.DeclaratorSuffix;
import at.jku.weiner.c.parser.parser.DirectDeclarator;
import at.jku.weiner.c.parser.parser.DirectDeclaratorLastSuffix;
import at.jku.weiner.c.parser.parser.EnumSpecifier;
import at.jku.weiner.c.parser.parser.Enumerator;
import at.jku.weiner.c.parser.parser.EnumeratorList;
import at.jku.weiner.c.parser.parser.EqualityExpression;
import at.jku.weiner.c.parser.parser.ExclusiveOrExpression;
import at.jku.weiner.c.parser.parser.Expression;
import at.jku.weiner.c.parser.parser.ExpressionStatement;
import at.jku.weiner.c.parser.parser.ExternalDeclaration;
import at.jku.weiner.c.parser.parser.FunctionDeclarationSpecifiers;
import at.jku.weiner.c.parser.parser.FunctionDefHead;
import at.jku.weiner.c.parser.parser.FunctionDefinition;
import at.jku.weiner.c.parser.parser.FunctionSpecifier;
import at.jku.weiner.c.parser.parser.IdentifierList;
import at.jku.weiner.c.parser.parser.InclusiveOrExpression;
import at.jku.weiner.c.parser.parser.InitDeclarator;
import at.jku.weiner.c.parser.parser.InitDeclaratorList;
import at.jku.weiner.c.parser.parser.Initializer;
import at.jku.weiner.c.parser.parser.InitializerList;
import at.jku.weiner.c.parser.parser.IterationStatement;
import at.jku.weiner.c.parser.parser.JumpStatement;
import at.jku.weiner.c.parser.parser.LabeledStatement;
import at.jku.weiner.c.parser.parser.LogicalAndExpression;
import at.jku.weiner.c.parser.parser.LogicalOrExpression;
import at.jku.weiner.c.parser.parser.Model;
import at.jku.weiner.c.parser.parser.MultiplicativeExpression;
import at.jku.weiner.c.parser.parser.MyIdentifier;
import at.jku.weiner.c.parser.parser.ParameterDeclaration;
import at.jku.weiner.c.parser.parser.ParameterList;
import at.jku.weiner.c.parser.parser.ParameterTypeList;
import at.jku.weiner.c.parser.parser.ParserPackage;
import at.jku.weiner.c.parser.parser.Pointer;
import at.jku.weiner.c.parser.parser.PostfixExpression;
import at.jku.weiner.c.parser.parser.PostfixExpressionSuffixArgument;
import at.jku.weiner.c.parser.parser.PostfixExpressionSuffixArray;
import at.jku.weiner.c.parser.parser.PostfixExpressionSuffixArrow;
import at.jku.weiner.c.parser.parser.PostfixExpressionSuffixDot;
import at.jku.weiner.c.parser.parser.PostfixExpressionSuffixMinusMinus;
import at.jku.weiner.c.parser.parser.PostfixExpressionSuffixPlusPlus;
import at.jku.weiner.c.parser.parser.PrimaryExpression;
import at.jku.weiner.c.parser.parser.RelationalExpression;
import at.jku.weiner.c.parser.parser.SelectionStatement;
import at.jku.weiner.c.parser.parser.ShiftExpression;
import at.jku.weiner.c.parser.parser.SpecifierQualifierList;
import at.jku.weiner.c.parser.parser.Statement;
import at.jku.weiner.c.parser.parser.StorageClassSpecifier;
import at.jku.weiner.c.parser.parser.StructDeclaration;
import at.jku.weiner.c.parser.parser.StructDeclarationList;
import at.jku.weiner.c.parser.parser.StructDeclarator;
import at.jku.weiner.c.parser.parser.StructDeclaratorList;
import at.jku.weiner.c.parser.parser.StructOrUnion;
import at.jku.weiner.c.parser.parser.StructOrUnionSpecifier;
import at.jku.weiner.c.parser.parser.TranslationUnit;
import at.jku.weiner.c.parser.parser.TypeName;
import at.jku.weiner.c.parser.parser.TypeQualifier;
import at.jku.weiner.c.parser.parser.TypeQualifierList;
import at.jku.weiner.c.parser.parser.TypeSpecifier;
import at.jku.weiner.c.parser.parser.TypedefName;
import at.jku.weiner.c.parser.parser.UnaryExpression;
import at.jku.weiner.c.parser.parser.UnaryOperator;
import at.jku.weiner.c.parser.services.ParserGrammarAccess;
import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ParserSemanticSequencer extends CommonSemanticSequencer {

	@Inject
	private ParserGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == CommonPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case CommonPackage.COMMON:
				sequence_Common(context, (Common) semanticObject); 
				return; 
			}
		else if(semanticObject.eClass().getEPackage() == ParserPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case ParserPackage.ADDITIVE_EXPRESSION:
				sequence_AdditiveExpression(context, (AdditiveExpression) semanticObject); 
				return; 
			case ParserPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case ParserPackage.ARGUMENT_EXPRESSION_LIST:
				sequence_ArgumentExpressionList(context, (ArgumentExpressionList) semanticObject); 
				return; 
			case ParserPackage.ASM_LINE_WITH_COLON:
				sequence_AsmLineWithColon(context, (AsmLineWithColon) semanticObject); 
				return; 
			case ParserPackage.ASM_LINE_WITH_COMMA:
				sequence_AsmLineWithComma(context, (AsmLineWithComma) semanticObject); 
				return; 
			case ParserPackage.ASM_STATEMENT:
				sequence_AsmStatement(context, (AsmStatement) semanticObject); 
				return; 
			case ParserPackage.ASSIGNMENT_EXPRESSION:
				sequence_AssignmentExpression(context, (AssignmentExpression) semanticObject); 
				return; 
			case ParserPackage.ASSIGNMENT_OPERATOR:
				sequence_AssignmentOperator(context, (AssignmentOperator) semanticObject); 
				return; 
			case ParserPackage.BLOCK_LIST:
				sequence_BlockList(context, (BlockList) semanticObject); 
				return; 
			case ParserPackage.BODY_STATEMENT:
				sequence_BodyStatement(context, (BodyStatement) semanticObject); 
				return; 
			case ParserPackage.CAST_EXPRESSION:
				sequence_CastExpression(context, (CastExpression) semanticObject); 
				return; 
			case ParserPackage.COMPOUND_STATEMENT:
				sequence_CompoundStatement(context, (CompoundStatement) semanticObject); 
				return; 
			case ParserPackage.CONDITIONAL_EXPRESSION:
				sequence_ConditionalExpression(context, (ConditionalExpression) semanticObject); 
				return; 
			case ParserPackage.CONSTANT:
				sequence_Constant(context, (Constant) semanticObject); 
				return; 
			case ParserPackage.CONSTANT_EXPRESSION:
				sequence_ConstantExpression(context, (ConstantExpression) semanticObject); 
				return; 
			case ParserPackage.DECLARATION:
				sequence_Declaration(context, (Declaration) semanticObject); 
				return; 
			case ParserPackage.DECLARATION_SPECIFIERS:
				sequence_DeclarationSpecifiers(context, (DeclarationSpecifiers) semanticObject); 
				return; 
			case ParserPackage.DECLARATOR:
				sequence_Declarator(context, (Declarator) semanticObject); 
				return; 
			case ParserPackage.DECLARATOR_SUFFIX:
				sequence_DeclaratorSuffix(context, (DeclaratorSuffix) semanticObject); 
				return; 
			case ParserPackage.DIRECT_DECLARATOR:
				sequence_DirectDeclarator(context, (DirectDeclarator) semanticObject); 
				return; 
			case ParserPackage.DIRECT_DECLARATOR_LAST_SUFFIX:
				sequence_DirectDeclaratorLastSuffix(context, (DirectDeclaratorLastSuffix) semanticObject); 
				return; 
			case ParserPackage.ENUM_SPECIFIER:
				sequence_EnumSpecifier(context, (EnumSpecifier) semanticObject); 
				return; 
			case ParserPackage.ENUMERATOR:
				sequence_Enumerator(context, (Enumerator) semanticObject); 
				return; 
			case ParserPackage.ENUMERATOR_LIST:
				sequence_EnumeratorList(context, (EnumeratorList) semanticObject); 
				return; 
			case ParserPackage.EQUALITY_EXPRESSION:
				sequence_EqualityExpression(context, (EqualityExpression) semanticObject); 
				return; 
			case ParserPackage.EXCLUSIVE_OR_EXPRESSION:
				sequence_ExclusiveOrExpression(context, (ExclusiveOrExpression) semanticObject); 
				return; 
			case ParserPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case ParserPackage.EXPRESSION_STATEMENT:
				sequence_ExpressionStatement(context, (ExpressionStatement) semanticObject); 
				return; 
			case ParserPackage.EXTERNAL_DECLARATION:
				sequence_ExternalDeclaration(context, (ExternalDeclaration) semanticObject); 
				return; 
			case ParserPackage.FUNCTION_DECLARATION_SPECIFIERS:
				sequence_FunctionDeclarationSpecifiers(context, (FunctionDeclarationSpecifiers) semanticObject); 
				return; 
			case ParserPackage.FUNCTION_DEF_HEAD:
				sequence_FunctionDefHead(context, (FunctionDefHead) semanticObject); 
				return; 
			case ParserPackage.FUNCTION_DEFINITION:
				sequence_FunctionDefinition(context, (FunctionDefinition) semanticObject); 
				return; 
			case ParserPackage.FUNCTION_SPECIFIER:
				sequence_FunctionSpecifier(context, (FunctionSpecifier) semanticObject); 
				return; 
			case ParserPackage.IDENTIFIER_LIST:
				sequence_IdentifierList(context, (IdentifierList) semanticObject); 
				return; 
			case ParserPackage.INCLUSIVE_OR_EXPRESSION:
				sequence_InclusiveOrExpression(context, (InclusiveOrExpression) semanticObject); 
				return; 
			case ParserPackage.INIT_DECLARATOR:
				sequence_InitDeclarator(context, (InitDeclarator) semanticObject); 
				return; 
			case ParserPackage.INIT_DECLARATOR_LIST:
				sequence_InitDeclaratorList(context, (InitDeclaratorList) semanticObject); 
				return; 
			case ParserPackage.INITIALIZER:
				sequence_Initializer(context, (Initializer) semanticObject); 
				return; 
			case ParserPackage.INITIALIZER_LIST:
				sequence_InitializerList(context, (InitializerList) semanticObject); 
				return; 
			case ParserPackage.ITERATION_STATEMENT:
				sequence_IterationStatement(context, (IterationStatement) semanticObject); 
				return; 
			case ParserPackage.JUMP_STATEMENT:
				sequence_JumpStatement(context, (JumpStatement) semanticObject); 
				return; 
			case ParserPackage.LABELED_STATEMENT:
				sequence_LabeledStatement(context, (LabeledStatement) semanticObject); 
				return; 
			case ParserPackage.LOGICAL_AND_EXPRESSION:
				sequence_LogicalAndExpression(context, (LogicalAndExpression) semanticObject); 
				return; 
			case ParserPackage.LOGICAL_OR_EXPRESSION:
				sequence_LogicalOrExpression(context, (LogicalOrExpression) semanticObject); 
				return; 
			case ParserPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ParserPackage.MULTIPLICATIVE_EXPRESSION:
				sequence_MultiplicativeExpression(context, (MultiplicativeExpression) semanticObject); 
				return; 
			case ParserPackage.MY_IDENTIFIER:
				sequence_MyIdentifier(context, (MyIdentifier) semanticObject); 
				return; 
			case ParserPackage.PARAMETER_DECLARATION:
				sequence_ParameterDeclaration(context, (ParameterDeclaration) semanticObject); 
				return; 
			case ParserPackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case ParserPackage.PARAMETER_TYPE_LIST:
				sequence_ParameterTypeList(context, (ParameterTypeList) semanticObject); 
				return; 
			case ParserPackage.POINTER:
				sequence_Pointer(context, (Pointer) semanticObject); 
				return; 
			case ParserPackage.POSTFIX_EXPRESSION:
				sequence_PostfixExpression(context, (PostfixExpression) semanticObject); 
				return; 
			case ParserPackage.POSTFIX_EXPRESSION_SUFFIX_ARGUMENT:
				sequence_PostfixExpressionSuffixArgument(context, (PostfixExpressionSuffixArgument) semanticObject); 
				return; 
			case ParserPackage.POSTFIX_EXPRESSION_SUFFIX_ARRAY:
				sequence_PostfixExpressionSuffixArray(context, (PostfixExpressionSuffixArray) semanticObject); 
				return; 
			case ParserPackage.POSTFIX_EXPRESSION_SUFFIX_ARROW:
				sequence_PostfixExpressionSuffixArrow(context, (PostfixExpressionSuffixArrow) semanticObject); 
				return; 
			case ParserPackage.POSTFIX_EXPRESSION_SUFFIX_DOT:
				sequence_PostfixExpressionSuffixDot(context, (PostfixExpressionSuffixDot) semanticObject); 
				return; 
			case ParserPackage.POSTFIX_EXPRESSION_SUFFIX_MINUS_MINUS:
				sequence_PostfixExpressionSuffixMinusMinus(context, (PostfixExpressionSuffixMinusMinus) semanticObject); 
				return; 
			case ParserPackage.POSTFIX_EXPRESSION_SUFFIX_PLUS_PLUS:
				sequence_PostfixExpressionSuffixPlusPlus(context, (PostfixExpressionSuffixPlusPlus) semanticObject); 
				return; 
			case ParserPackage.PRIMARY_EXPRESSION:
				sequence_PrimaryExpression(context, (PrimaryExpression) semanticObject); 
				return; 
			case ParserPackage.RELATIONAL_EXPRESSION:
				sequence_RelationalExpression(context, (RelationalExpression) semanticObject); 
				return; 
			case ParserPackage.SELECTION_STATEMENT:
				sequence_SelectionStatement(context, (SelectionStatement) semanticObject); 
				return; 
			case ParserPackage.SHIFT_EXPRESSION:
				sequence_ShiftExpression(context, (ShiftExpression) semanticObject); 
				return; 
			case ParserPackage.SPECIFIER_QUALIFIER_LIST:
				sequence_SpecifierQualifierList(context, (SpecifierQualifierList) semanticObject); 
				return; 
			case ParserPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case ParserPackage.STORAGE_CLASS_SPECIFIER:
				sequence_StorageClassSpecifier(context, (StorageClassSpecifier) semanticObject); 
				return; 
			case ParserPackage.STRUCT_DECLARATION:
				sequence_StructDeclaration(context, (StructDeclaration) semanticObject); 
				return; 
			case ParserPackage.STRUCT_DECLARATION_LIST:
				sequence_StructDeclarationList(context, (StructDeclarationList) semanticObject); 
				return; 
			case ParserPackage.STRUCT_DECLARATOR:
				sequence_StructDeclarator(context, (StructDeclarator) semanticObject); 
				return; 
			case ParserPackage.STRUCT_DECLARATOR_LIST:
				sequence_StructDeclaratorList(context, (StructDeclaratorList) semanticObject); 
				return; 
			case ParserPackage.STRUCT_OR_UNION:
				sequence_StructOrUnion(context, (StructOrUnion) semanticObject); 
				return; 
			case ParserPackage.STRUCT_OR_UNION_SPECIFIER:
				sequence_StructOrUnionSpecifier(context, (StructOrUnionSpecifier) semanticObject); 
				return; 
			case ParserPackage.TRANSLATION_UNIT:
				sequence_TranslationUnit(context, (TranslationUnit) semanticObject); 
				return; 
			case ParserPackage.TYPE_NAME:
				sequence_TypeName(context, (TypeName) semanticObject); 
				return; 
			case ParserPackage.TYPE_QUALIFIER:
				sequence_TypeQualifier(context, (TypeQualifier) semanticObject); 
				return; 
			case ParserPackage.TYPE_QUALIFIER_LIST:
				sequence_TypeQualifierList(context, (TypeQualifierList) semanticObject); 
				return; 
			case ParserPackage.TYPE_SPECIFIER:
				sequence_TypeSpecifier(context, (TypeSpecifier) semanticObject); 
				return; 
			case ParserPackage.TYPEDEF_NAME:
				sequence_TypedefName(context, (TypedefName) semanticObject); 
				return; 
			case ParserPackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case ParserPackage.UNARY_OPERATOR:
				sequence_UnaryOperator(context, (UnaryOperator) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (expr+=MultiplicativeExpression ((op+=SKW_PLUS | op+=SKW_MINUS) expr+=MultiplicativeExpression)*)
	 */
	protected void sequence_AdditiveExpression(EObject context, AdditiveExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expr+=EqualityExpression expr+=EqualityExpression*)
	 */
	protected void sequence_AndExpression(EObject context, AndExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expr+=AssignmentExpression expr+=AssignmentExpression*)
	 */
	protected void sequence_ArgumentExpressionList(EObject context, ArgumentExpressionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (colon?=SKW_COLON? expr=LogicalOrExpression)
	 */
	protected void sequence_AsmLineWithColon(EObject context, AsmLineWithColon semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expr=LogicalOrExpression
	 */
	protected void sequence_AsmLineWithComma(EObject context, AsmLineWithComma semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.ASM_LINE__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.ASM_LINE__EXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAsmLineWithCommaAccess().getExprLogicalOrExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (asm=KW_ASM1 | asm=KW_ASM2) 
	 *         (volatile=KW_VOLATILE | volatile=KW_VOLATILE2)? 
	 *         (asmLine+=AsmLineWithColon asmLine+=AsmLineWithComma*)+ 
	 *         semi=SKW_SEMI
	 *     )
	 */
	protected void sequence_AsmStatement(EObject context, AsmStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((expr=Lvalue op=AssignmentOperator assignmentExpr=AssignmentExpression) | expr=ConditionalExpression)
	 */
	protected void sequence_AssignmentExpression(EObject context, AssignmentExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         op=SKW_ASSIGN | 
	 *         op=STARASSIGN | 
	 *         op=DIVASSIGN | 
	 *         op=MODASSIGN | 
	 *         op=PLUSASSIGN | 
	 *         op=MINUSASSIGN | 
	 *         op=LEFTSHIFTASSIGN | 
	 *         op=RIGHTSHIFTASSIGN | 
	 *         op=ANDASSIGN | 
	 *         op=XORASSIGN | 
	 *         op=ORASSIGN
	 *     )
	 */
	protected void sequence_AssignmentOperator(EObject context, AssignmentOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (declaration+=Declaration | statement+=Statement)+
	 */
	protected void sequence_BlockList(EObject context, BlockList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (blockList+=BlockList?)
	 */
	protected void sequence_BodyStatement(EObject context, BodyStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expr=UnaryExpression | (type=TypeName expr=CastExpression))
	 */
	protected void sequence_CastExpression(EObject context, CastExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     body=BodyStatement
	 */
	protected void sequence_CompoundStatement(EObject context, CompoundStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expr=LogicalOrExpression (qExpr=Expression cExpr=ConditionalExpression)?)
	 */
	protected void sequence_ConditionalExpression(EObject context, ConditionalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expr=ConditionalExpression
	 */
	protected void sequence_ConstantExpression(EObject context, ConstantExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         hex=HEX_LITERAL | 
	 *         oct=OCTAL_LITERAL | 
	 *         dec=DECIMAL_LITERAL | 
	 *         ch=CHAR_LITERAL | 
	 *         str=STRING_LITERAL | 
	 *         float=FLOAT_LITERAL | 
	 *         bin=BIN_LITERAL
	 *     )
	 */
	protected void sequence_Constant(EObject context, Constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         declarationSpecifier+=StorageClassSpecifier | 
	 *         declarationSpecifier+=TypeSpecifier | 
	 *         declarationSpecifier+=TypeQualifier | 
	 *         declarationSpecifier+=StructOrUnionSpecifier
	 *     )+
	 */
	protected void sequence_DeclarationSpecifiers(EObject context, DeclarationSpecifiers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (specifiers=DeclarationSpecifiers initDeclaratorList+=InitDeclaratorList? semi=SKW_SEMI)
	 */
	protected void sequence_Declaration(EObject context, Declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (static=KW_STATIC typeQualifierList=TypeQualifierList? expr=AssignmentExpression?) | 
	 *         (typeQualifierList=TypeQualifierList? expr=AssignmentExpression) | 
	 *         (typeQualifierList=TypeQualifierList static=KW_STATIC expr=AssignmentExpression) | 
	 *         (typeQualifierList=TypeQualifierList? star=SKW_STAR) | 
	 *         lastSuffix=DirectDeclaratorLastSuffix
	 *     )
	 */
	protected void sequence_DeclaratorSuffix(EObject context, DeclaratorSuffix semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (pointer=Pointer? declarator=DirectDeclarator)
	 */
	protected void sequence_Declarator(EObject context, Declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (parameterTypeList+=ParameterTypeList | identifierList=IdentifierList?)
	 */
	protected void sequence_DirectDeclaratorLastSuffix(EObject context, DirectDeclaratorLastSuffix semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((id=ID | declarator=Declarator) declaratorSuffix+=DeclaratorSuffix*)
	 */
	protected void sequence_DirectDeclarator(EObject context, DirectDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (enumList=EnumeratorList | (id=ID enumList=EnumeratorList?))
	 */
	protected void sequence_EnumSpecifier(EObject context, EnumSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (enumerator+=Enumerator enumerator+=Enumerator*)
	 */
	protected void sequence_EnumeratorList(EObject context, EnumeratorList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id=ID expr=ConstantExpression?)
	 */
	protected void sequence_Enumerator(EObject context, Enumerator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expr+=RelationalExpression ((op+=SKW_EQUAL | op+=SKW_NOTEQUAL) expr+=RelationalExpression)*)
	 */
	protected void sequence_EqualityExpression(EObject context, EqualityExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expr+=AndExpression expr+=AndExpression*)
	 */
	protected void sequence_ExclusiveOrExpression(EObject context, ExclusiveOrExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expression=Expression? semi=SKW_SEMI)
	 */
	protected void sequence_ExpressionStatement(EObject context, ExpressionStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (exprExpr+=AssignmentExpression exprExpr+=AssignmentExpression*)
	 */
	protected void sequence_Expression(EObject context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((functiondefHead=FunctionDefHead functionDefinition=FunctionDefinition) | declaration=Declaration | semi=SKW_SEMI)
	 */
	protected void sequence_ExternalDeclaration(EObject context, ExternalDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         declarationSpecifier+=StorageClassSpecifier | 
	 *         declarationSpecifier+=TypeSpecifier | 
	 *         declarationSpecifier+=TypeQualifier | 
	 *         declarationSpecifier+=FunctionSpecifier
	 *     )+
	 */
	protected void sequence_FunctionDeclarationSpecifiers(EObject context, FunctionDeclarationSpecifiers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (funDeclSpecifiers=FunctionDeclarationSpecifiers? funDeclarator=Declarator funDeclaration+=Declaration*)
	 */
	protected void sequence_FunctionDefHead(EObject context, FunctionDefHead semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     body=BodyStatement
	 */
	protected void sequence_FunctionDefinition(EObject context, FunctionDefinition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.FUNCTION_DEFINITION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.FUNCTION_DEFINITION__BODY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFunctionDefinitionAccess().getBodyBodyStatementParserRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=KW_INLINE | name=KW_NORETURN)
	 */
	protected void sequence_FunctionSpecifier(EObject context, FunctionSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id+=MyIdentifier id+=MyIdentifier*)
	 */
	protected void sequence_IdentifierList(EObject context, IdentifierList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expr+=ExclusiveOrExpression expr+=ExclusiveOrExpression*)
	 */
	protected void sequence_InclusiveOrExpression(EObject context, InclusiveOrExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (initDeclarator+=InitDeclarator initDeclarator+=InitDeclarator*)
	 */
	protected void sequence_InitDeclaratorList(EObject context, InitDeclaratorList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (declarator=Declarator initializer=Initializer?)
	 */
	protected void sequence_InitDeclarator(EObject context, InitDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (initializer+=Initializer initializer+=Initializer*)
	 */
	protected void sequence_InitializerList(EObject context, InitializerList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expr=AssignmentExpression | list=InitializerList)
	 */
	protected void sequence_Initializer(EObject context, Initializer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (while=KW_WHILE expr=Expression statement=Statement) | 
	 *         (do=KW_DO statement=Statement expr=Expression semi=SKW_SEMI) | 
	 *         (for=KW_FOR initExpr=Expression? expr=Expression? incExpr=Expression? statement=Statement) | 
	 *         (for=KW_FOR initDecl=Declaration expr=Expression? incExpr=Expression? statement=Statement)
	 *     )
	 */
	protected void sequence_IterationStatement(EObject context, IterationStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (continue=KW_CONTINUE semi=SKW_SEMI) | 
	 *         (break=KW_BREAK semi=SKW_SEMI) | 
	 *         (return=KW_RETURN expr=Expression? semi=SKW_SEMI) | 
	 *         (goto=KW_GOTO expr=UnaryExpression semi=SKW_SEMI)
	 *     )
	 */
	protected void sequence_JumpStatement(EObject context, JumpStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((id=ID lStmt=Statement) | (case=KW_CASE expr=ConstantExpression lStmt=Statement) | (default=KW_DEFAULT lStmt=Statement))
	 */
	protected void sequence_LabeledStatement(EObject context, LabeledStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expr+=InclusiveOrExpression expr+=InclusiveOrExpression*)
	 */
	protected void sequence_LogicalAndExpression(EObject context, LogicalAndExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expr+=LogicalAndExpression expr+=LogicalAndExpression*)
	 */
	protected void sequence_LogicalOrExpression(EObject context, LogicalOrExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     unit+=TranslationUnit
	 */
	protected void sequence_Model(EObject context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expr+=CastExpression ((op+=SKW_STAR | op+=SKW_DIV | op+=SKW_MOD) expr+=CastExpression)*)
	 */
	protected void sequence_MultiplicativeExpression(EObject context, MultiplicativeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_MyIdentifier(EObject context, MyIdentifier semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.MY_IDENTIFIER__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.MY_IDENTIFIER__ID));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMyIdentifierAccess().getIdIDTerminalRuleCall_1_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (declSpecifiers=DeclarationSpecifiers declarator=Declarator?)
	 */
	protected void sequence_ParameterDeclaration(EObject context, ParameterDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (parameterDeclaration+=ParameterDeclaration parameterDeclaration+=ParameterDeclaration*)
	 */
	protected void sequence_ParameterList(EObject context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     list=ParameterList
	 */
	protected void sequence_ParameterTypeList(EObject context, ParameterTypeList semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.PARAMETER_TYPE_LIST__LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.PARAMETER_TYPE_LIST__LIST));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getParameterTypeListAccess().getListParameterListParserRuleCall_1_0(), semanticObject.getList());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (((star+=SKW_STAR | caret+=SKW_CARET) typeQualifierList+=TypeQualifierList?)*)
	 */
	protected void sequence_Pointer(EObject context, Pointer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (argumentExpressionList=ArgumentExpressionList?)
	 */
	protected void sequence_PostfixExpressionSuffixArgument(EObject context, PostfixExpressionSuffixArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     arrayExpr=Expression
	 */
	protected void sequence_PostfixExpressionSuffixArray(EObject context, PostfixExpressionSuffixArray semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.POSTFIX_EXPRESSION_SUFFIX_ARRAY__ARRAY_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.POSTFIX_EXPRESSION_SUFFIX_ARRAY__ARRAY_EXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPostfixExpressionSuffixArrayAccess().getArrayExprExpressionParserRuleCall_2_0(), semanticObject.getArrayExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_PostfixExpressionSuffixArrow(EObject context, PostfixExpressionSuffixArrow semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.POSTFIX_EXPRESSION_SUFFIX_ARROW__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.POSTFIX_EXPRESSION_SUFFIX_ARROW__ID));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPostfixExpressionSuffixArrowAccess().getIdIDTerminalRuleCall_2_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_PostfixExpressionSuffixDot(EObject context, PostfixExpressionSuffixDot semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.POSTFIX_EXPRESSION_SUFFIX_DOT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.POSTFIX_EXPRESSION_SUFFIX_DOT__ID));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPostfixExpressionSuffixDotAccess().getIdIDTerminalRuleCall_2_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {PostfixExpressionSuffixMinusMinus}
	 */
	protected void sequence_PostfixExpressionSuffixMinusMinus(EObject context, PostfixExpressionSuffixMinusMinus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {PostfixExpressionSuffixPlusPlus}
	 */
	protected void sequence_PostfixExpressionSuffixPlusPlus(EObject context, PostfixExpressionSuffixPlusPlus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         expr+=PrimaryExpression 
	 *         (
	 *             suffix+=PostfixExpressionSuffixArray | 
	 *             suffix+=PostfixExpressionSuffixArgument | 
	 *             suffix+=PostfixExpressionSuffixDot | 
	 *             suffix+=PostfixExpressionSuffixArrow | 
	 *             suffix+=PostfixExpressionSuffixPlusPlus | 
	 *             suffix+=PostfixExpressionSuffixMinusMinus
	 *         )*
	 *     )
	 */
	protected void sequence_PostfixExpression(EObject context, PostfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id=ID | const=Constant | expr=Expression)
	 */
	protected void sequence_PrimaryExpression(EObject context, PrimaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expr+=ShiftExpression ((op+=SKW_LESS | op+=SKW_GREATER | op+=SKW_LESSEQUAL | op+=SKW_GREATEREQUAL) expr+=ShiftExpression)*)
	 */
	protected void sequence_RelationalExpression(EObject context, RelationalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (if=KW_IF expr=Expression ifStatement=Statement (else=KW_ELSE elseStatement=Statement)?) | 
	 *         (switch=KW_SWITCH expr=Expression switchStatement=Statement)
	 *     )
	 */
	protected void sequence_SelectionStatement(EObject context, SelectionStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expr+=AdditiveExpression ((op+=SKW_LEFTSHIFT | op+=SKW_RIGHTSHIFT) expr+=AdditiveExpression)*)
	 */
	protected void sequence_ShiftExpression(EObject context, ShiftExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (typeSpecifier+=TypeSpecifier | typeQualifier+=TypeQualifier | structOrUnionSpecifier+=StructOrUnionSpecifier)+
	 */
	protected void sequence_SpecifierQualifierList(EObject context, SpecifierQualifierList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         stmt=LabeledStatement | 
	 *         stmt=CompoundStatement | 
	 *         stmt=ExpressionStatement | 
	 *         stmt=SelectionStatement | 
	 *         stmt=IterationStatement | 
	 *         stmt=JumpStatement | 
	 *         stmt=AsmStatement
	 *     )
	 */
	protected void sequence_Statement(EObject context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=KW_TYPEDEF | 
	 *         name=KW_EXTERN | 
	 *         name=KW_STATIC | 
	 *         name=KW_THREADLOCAL | 
	 *         name=KW_AUTO | 
	 *         name=KW_REGISTER
	 *     )
	 */
	protected void sequence_StorageClassSpecifier(EObject context, StorageClassSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     structDeclaration+=StructDeclaration+
	 */
	protected void sequence_StructDeclarationList(EObject context, StructDeclarationList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (list=SpecifierQualifierList structDeclarationList=StructDeclaratorList?)
	 */
	protected void sequence_StructDeclaration(EObject context, StructDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (structDeclarator+=StructDeclarator structDeclarator+=StructDeclarator*)
	 */
	protected void sequence_StructDeclaratorList(EObject context, StructDeclaratorList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((declarator=Declarator constExpr+=ConstantExpression?) | constExpr+=ConstantExpression)
	 */
	protected void sequence_StructDeclarator(EObject context, StructDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=StructOrUnion ((id=ID? structDeclList=StructDeclarationList) | id=ID))
	 */
	protected void sequence_StructOrUnionSpecifier(EObject context, StructOrUnionSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=KW_STRUCT
	 */
	protected void sequence_StructOrUnion(EObject context, StructOrUnion semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.STRUCT_OR_UNION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.STRUCT_OR_UNION__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStructOrUnionAccess().getNameKW_STRUCTTerminalRuleCall_0_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (external+=ExternalDeclaration*)
	 */
	protected void sequence_TranslationUnit(EObject context, TranslationUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     list=SpecifierQualifierList
	 */
	protected void sequence_TypeName(EObject context, TypeName semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.TYPE_NAME__LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.TYPE_NAME__LIST));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTypeNameAccess().getListSpecifierQualifierListParserRuleCall_1_0(), semanticObject.getList());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     typeQualifier+=TypeQualifier+
	 */
	protected void sequence_TypeQualifierList(EObject context, TypeQualifierList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=KW_CONST | type=KW_RESTRICT | type=KW_VOLATILE | type=KW_ATOMIC)
	 */
	protected void sequence_TypeQualifier(EObject context, TypeQualifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=KW_VOID
	 */
	protected void sequence_TypeSpecifier(EObject context, TypeSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_TypedefName(EObject context, TypedefName semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.TYPEDEF_NAME__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.TYPEDEF_NAME__ID));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTypedefNameAccess().getIdIDTerminalRuleCall_1_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         expr=PostfixExpression | 
	 *         (plusplus=SKW_PLUSPLUS expr=UnaryExpression) | 
	 *         (minusminus=SKW_MINUSMINUS expr=UnaryExpression) | 
	 *         (op=UnaryOperator expr=CastExpression) | 
	 *         (sizeOf=KW_SIZEOF typeName=TypeName) | 
	 *         (sizeOf=KW_SIZEOF expr=UnaryExpression) | 
	 *         (andand=SKW_ANDAND id=ID)
	 *     )
	 */
	protected void sequence_UnaryExpression(EObject context, UnaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         op=SKW_AND | 
	 *         op=SKW_STAR | 
	 *         op=SKW_PLUS | 
	 *         op=SKW_MINUS | 
	 *         op=SKW_TILDE | 
	 *         op=SKW_NOT
	 *     )
	 */
	protected void sequence_UnaryOperator(EObject context, UnaryOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
