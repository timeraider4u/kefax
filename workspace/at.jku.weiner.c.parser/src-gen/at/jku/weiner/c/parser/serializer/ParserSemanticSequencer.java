/*
 * generated by Xtext 2.9.0-SNAPSHOT
 */
package at.jku.weiner.c.parser.serializer;

import at.jku.weiner.c.common.common.CommonPackage;
import at.jku.weiner.c.common.common.Constant2;
import at.jku.weiner.c.common.serializer.CommonSemanticSequencer;
import at.jku.weiner.c.parser.parser.AbstractDeclarator;
import at.jku.weiner.c.parser.parser.AbstractDeclaratorSuffix;
import at.jku.weiner.c.parser.parser.AdditiveExpression;
import at.jku.weiner.c.parser.parser.AndExpression;
import at.jku.weiner.c.parser.parser.ArgumentExpressionList;
import at.jku.weiner.c.parser.parser.AsmLine;
import at.jku.weiner.c.parser.parser.AsmLineWithColon;
import at.jku.weiner.c.parser.parser.AsmLineWithoutColon;
import at.jku.weiner.c.parser.parser.AsmStatement;
import at.jku.weiner.c.parser.parser.AsmSymbolicName;
import at.jku.weiner.c.parser.parser.AssignmentExpression;
import at.jku.weiner.c.parser.parser.BlockList;
import at.jku.weiner.c.parser.parser.BodyStatement;
import at.jku.weiner.c.parser.parser.CastExpression;
import at.jku.weiner.c.parser.parser.CompoundStatement;
import at.jku.weiner.c.parser.parser.ConditionalExpression;
import at.jku.weiner.c.parser.parser.Declaration;
import at.jku.weiner.c.parser.parser.DeclarationSpecifiers;
import at.jku.weiner.c.parser.parser.Declarator;
import at.jku.weiner.c.parser.parser.DeclaratorSuffix;
import at.jku.weiner.c.parser.parser.Designation;
import at.jku.weiner.c.parser.parser.Designator;
import at.jku.weiner.c.parser.parser.DesignatorList;
import at.jku.weiner.c.parser.parser.DirectAbstractDeclarator;
import at.jku.weiner.c.parser.parser.DirectDeclarator;
import at.jku.weiner.c.parser.parser.DirectDeclaratorLastSuffix;
import at.jku.weiner.c.parser.parser.EnumSpecifier;
import at.jku.weiner.c.parser.parser.Enumerator;
import at.jku.weiner.c.parser.parser.EnumeratorList;
import at.jku.weiner.c.parser.parser.EqualityExpression;
import at.jku.weiner.c.parser.parser.ExclusiveOrExpression;
import at.jku.weiner.c.parser.parser.Expression;
import at.jku.weiner.c.parser.parser.ExpressionStatement;
import at.jku.weiner.c.parser.parser.ExternalDeclaration;
import at.jku.weiner.c.parser.parser.FunctionDeclarationSpecifiers;
import at.jku.weiner.c.parser.parser.FunctionDefHead;
import at.jku.weiner.c.parser.parser.FunctionDefinition;
import at.jku.weiner.c.parser.parser.FunctionSpecifier;
import at.jku.weiner.c.parser.parser.GccAttribute;
import at.jku.weiner.c.parser.parser.GccAttributeList;
import at.jku.weiner.c.parser.parser.GccAttributeSpecifier;
import at.jku.weiner.c.parser.parser.GccDeclaratorExtension;
import at.jku.weiner.c.parser.parser.IdentifierList;
import at.jku.weiner.c.parser.parser.InclusiveOrExpression;
import at.jku.weiner.c.parser.parser.Init;
import at.jku.weiner.c.parser.parser.InitDeclarator;
import at.jku.weiner.c.parser.parser.InitDeclaratorList;
import at.jku.weiner.c.parser.parser.Initializer;
import at.jku.weiner.c.parser.parser.InitializerList;
import at.jku.weiner.c.parser.parser.IterationStatement;
import at.jku.weiner.c.parser.parser.JumpStatement;
import at.jku.weiner.c.parser.parser.LabeledStatement;
import at.jku.weiner.c.parser.parser.LogicalAndExpression;
import at.jku.weiner.c.parser.parser.LogicalOrExpression;
import at.jku.weiner.c.parser.parser.MultiplicativeExpression;
import at.jku.weiner.c.parser.parser.MyIdentifier;
import at.jku.weiner.c.parser.parser.ParameterDeclaration;
import at.jku.weiner.c.parser.parser.ParameterList;
import at.jku.weiner.c.parser.parser.ParameterTypeList;
import at.jku.weiner.c.parser.parser.Parser;
import at.jku.weiner.c.parser.parser.ParserPackage;
import at.jku.weiner.c.parser.parser.Pointer;
import at.jku.weiner.c.parser.parser.PostfixExpression;
import at.jku.weiner.c.parser.parser.PostfixExpressionSuffixArgument;
import at.jku.weiner.c.parser.parser.PostfixExpressionSuffixArray;
import at.jku.weiner.c.parser.parser.PostfixExpressionSuffixArrow;
import at.jku.weiner.c.parser.parser.PostfixExpressionSuffixDot;
import at.jku.weiner.c.parser.parser.PostfixExpressionSuffixMinusMinus;
import at.jku.weiner.c.parser.parser.PostfixExpressionSuffixPlusPlus;
import at.jku.weiner.c.parser.parser.PrimaryExpression;
import at.jku.weiner.c.parser.parser.RelationalExpression;
import at.jku.weiner.c.parser.parser.SelectionStatement;
import at.jku.weiner.c.parser.parser.ShiftExpression;
import at.jku.weiner.c.parser.parser.SpecifierQualifierList;
import at.jku.weiner.c.parser.parser.Statement;
import at.jku.weiner.c.parser.parser.StorageClassSpecifier;
import at.jku.weiner.c.parser.parser.StructDeclaration;
import at.jku.weiner.c.parser.parser.StructDeclarationList;
import at.jku.weiner.c.parser.parser.StructDeclarator;
import at.jku.weiner.c.parser.parser.StructDeclaratorList;
import at.jku.weiner.c.parser.parser.StructOrUnion;
import at.jku.weiner.c.parser.parser.StructOrUnionSpecifier;
import at.jku.weiner.c.parser.parser.TypeName;
import at.jku.weiner.c.parser.parser.TypeQualifier;
import at.jku.weiner.c.parser.parser.TypeQualifierList;
import at.jku.weiner.c.parser.parser.TypeSpecifier;
import at.jku.weiner.c.parser.parser.TypedefName;
import at.jku.weiner.c.parser.parser.UnaryExpression;
import at.jku.weiner.c.parser.services.ParserGrammarAccess;
import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ParserSemanticSequencer extends CommonSemanticSequencer {

	@Inject
	private ParserGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == CommonPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case CommonPackage.CONSTANT2:
				sequence_Constant2(context, (Constant2) semanticObject); 
				return; 
			}
		else if(semanticObject.eClass().getEPackage() == ParserPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case ParserPackage.ABSTRACT_DECLARATOR:
				sequence_AbstractDeclarator(context, (AbstractDeclarator) semanticObject); 
				return; 
			case ParserPackage.ABSTRACT_DECLARATOR_SUFFIX:
				sequence_AbstractDeclaratorSuffix(context, (AbstractDeclaratorSuffix) semanticObject); 
				return; 
			case ParserPackage.ADDITIVE_EXPRESSION:
				sequence_AdditiveExpression(context, (AdditiveExpression) semanticObject); 
				return; 
			case ParserPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case ParserPackage.ARGUMENT_EXPRESSION_LIST:
				sequence_ArgumentExpressionList(context, (ArgumentExpressionList) semanticObject); 
				return; 
			case ParserPackage.ASM_LINE:
				sequence_AsmLine(context, (AsmLine) semanticObject); 
				return; 
			case ParserPackage.ASM_LINE_WITH_COLON:
				sequence_AsmLineWithColon(context, (AsmLineWithColon) semanticObject); 
				return; 
			case ParserPackage.ASM_LINE_WITHOUT_COLON:
				sequence_AsmLineWithoutColon(context, (AsmLineWithoutColon) semanticObject); 
				return; 
			case ParserPackage.ASM_STATEMENT:
				sequence_AsmStatement(context, (AsmStatement) semanticObject); 
				return; 
			case ParserPackage.ASM_SYMBOLIC_NAME:
				sequence_AsmSymbolicName(context, (AsmSymbolicName) semanticObject); 
				return; 
			case ParserPackage.ASSIGNMENT_EXPRESSION:
				sequence_AssignmentExpression(context, (AssignmentExpression) semanticObject); 
				return; 
			case ParserPackage.BLOCK_LIST:
				sequence_BlockList(context, (BlockList) semanticObject); 
				return; 
			case ParserPackage.BODY_STATEMENT:
				sequence_BodyStatement(context, (BodyStatement) semanticObject); 
				return; 
			case ParserPackage.CAST_EXPRESSION:
				sequence_CastExpression(context, (CastExpression) semanticObject); 
				return; 
			case ParserPackage.COMPOUND_STATEMENT:
				sequence_CompoundStatement(context, (CompoundStatement) semanticObject); 
				return; 
			case ParserPackage.CONDITIONAL_EXPRESSION:
				sequence_ConditionalExpression(context, (ConditionalExpression) semanticObject); 
				return; 
			case ParserPackage.DECLARATION:
				sequence_Declaration(context, (Declaration) semanticObject); 
				return; 
			case ParserPackage.DECLARATION_SPECIFIERS:
				sequence_DeclarationSpecifiers(context, (DeclarationSpecifiers) semanticObject); 
				return; 
			case ParserPackage.DECLARATOR:
				sequence_Declarator(context, (Declarator) semanticObject); 
				return; 
			case ParserPackage.DECLARATOR_SUFFIX:
				sequence_DeclaratorSuffix(context, (DeclaratorSuffix) semanticObject); 
				return; 
			case ParserPackage.DESIGNATION:
				sequence_Designation(context, (Designation) semanticObject); 
				return; 
			case ParserPackage.DESIGNATOR:
				sequence_Designator(context, (Designator) semanticObject); 
				return; 
			case ParserPackage.DESIGNATOR_LIST:
				sequence_DesignatorList(context, (DesignatorList) semanticObject); 
				return; 
			case ParserPackage.DIRECT_ABSTRACT_DECLARATOR:
				sequence_DirectAbstractDeclarator(context, (DirectAbstractDeclarator) semanticObject); 
				return; 
			case ParserPackage.DIRECT_DECLARATOR:
				sequence_DirectDeclarator(context, (DirectDeclarator) semanticObject); 
				return; 
			case ParserPackage.DIRECT_DECLARATOR_LAST_SUFFIX:
				sequence_DirectDeclaratorLastSuffix(context, (DirectDeclaratorLastSuffix) semanticObject); 
				return; 
			case ParserPackage.ENUM_SPECIFIER:
				sequence_EnumSpecifier(context, (EnumSpecifier) semanticObject); 
				return; 
			case ParserPackage.ENUMERATOR:
				sequence_Enumerator(context, (Enumerator) semanticObject); 
				return; 
			case ParserPackage.ENUMERATOR_LIST:
				sequence_EnumeratorList(context, (EnumeratorList) semanticObject); 
				return; 
			case ParserPackage.EQUALITY_EXPRESSION:
				sequence_EqualityExpression(context, (EqualityExpression) semanticObject); 
				return; 
			case ParserPackage.EXCLUSIVE_OR_EXPRESSION:
				sequence_ExclusiveOrExpression(context, (ExclusiveOrExpression) semanticObject); 
				return; 
			case ParserPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case ParserPackage.EXPRESSION_STATEMENT:
				sequence_ExpressionStatement(context, (ExpressionStatement) semanticObject); 
				return; 
			case ParserPackage.EXTERNAL_DECLARATION:
				sequence_ExternalDeclaration(context, (ExternalDeclaration) semanticObject); 
				return; 
			case ParserPackage.FUNCTION_DECLARATION_SPECIFIERS:
				sequence_FunctionDeclarationSpecifiers(context, (FunctionDeclarationSpecifiers) semanticObject); 
				return; 
			case ParserPackage.FUNCTION_DEF_HEAD:
				sequence_FunctionDefHead(context, (FunctionDefHead) semanticObject); 
				return; 
			case ParserPackage.FUNCTION_DEFINITION:
				sequence_FunctionDefinition(context, (FunctionDefinition) semanticObject); 
				return; 
			case ParserPackage.FUNCTION_SPECIFIER:
				sequence_FunctionSpecifier(context, (FunctionSpecifier) semanticObject); 
				return; 
			case ParserPackage.GCC_ATTRIBUTE:
				sequence_GccAttribute(context, (GccAttribute) semanticObject); 
				return; 
			case ParserPackage.GCC_ATTRIBUTE_LIST:
				sequence_GccAttributeList(context, (GccAttributeList) semanticObject); 
				return; 
			case ParserPackage.GCC_ATTRIBUTE_SPECIFIER:
				sequence_GccAttributeSpecifier(context, (GccAttributeSpecifier) semanticObject); 
				return; 
			case ParserPackage.GCC_DECLARATOR_EXTENSION:
				sequence_GccDeclaratorExtension(context, (GccDeclaratorExtension) semanticObject); 
				return; 
			case ParserPackage.IDENTIFIER_LIST:
				sequence_IdentifierList(context, (IdentifierList) semanticObject); 
				return; 
			case ParserPackage.INCLUSIVE_OR_EXPRESSION:
				sequence_InclusiveOrExpression(context, (InclusiveOrExpression) semanticObject); 
				return; 
			case ParserPackage.INIT:
				sequence_Init(context, (Init) semanticObject); 
				return; 
			case ParserPackage.INIT_DECLARATOR:
				sequence_InitDeclarator(context, (InitDeclarator) semanticObject); 
				return; 
			case ParserPackage.INIT_DECLARATOR_LIST:
				sequence_InitDeclaratorList(context, (InitDeclaratorList) semanticObject); 
				return; 
			case ParserPackage.INITIALIZER:
				sequence_Initializer(context, (Initializer) semanticObject); 
				return; 
			case ParserPackage.INITIALIZER_LIST:
				sequence_InitializerList(context, (InitializerList) semanticObject); 
				return; 
			case ParserPackage.ITERATION_STATEMENT:
				sequence_IterationStatement(context, (IterationStatement) semanticObject); 
				return; 
			case ParserPackage.JUMP_STATEMENT:
				sequence_JumpStatement(context, (JumpStatement) semanticObject); 
				return; 
			case ParserPackage.LABELED_STATEMENT:
				sequence_LabeledStatement(context, (LabeledStatement) semanticObject); 
				return; 
			case ParserPackage.LOGICAL_AND_EXPRESSION:
				sequence_LogicalAndExpression(context, (LogicalAndExpression) semanticObject); 
				return; 
			case ParserPackage.LOGICAL_OR_EXPRESSION:
				sequence_LogicalOrExpression(context, (LogicalOrExpression) semanticObject); 
				return; 
			case ParserPackage.MULTIPLICATIVE_EXPRESSION:
				sequence_MultiplicativeExpression(context, (MultiplicativeExpression) semanticObject); 
				return; 
			case ParserPackage.MY_IDENTIFIER:
				sequence_MyIdentifier(context, (MyIdentifier) semanticObject); 
				return; 
			case ParserPackage.PARAMETER_DECLARATION:
				sequence_ParameterDeclaration(context, (ParameterDeclaration) semanticObject); 
				return; 
			case ParserPackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case ParserPackage.PARAMETER_TYPE_LIST:
				sequence_ParameterTypeList(context, (ParameterTypeList) semanticObject); 
				return; 
			case ParserPackage.PARSER:
				sequence_Parser(context, (Parser) semanticObject); 
				return; 
			case ParserPackage.POINTER:
				sequence_Pointer(context, (Pointer) semanticObject); 
				return; 
			case ParserPackage.POSTFIX_EXPRESSION:
				sequence_PostfixExpression(context, (PostfixExpression) semanticObject); 
				return; 
			case ParserPackage.POSTFIX_EXPRESSION_SUFFIX_ARGUMENT:
				sequence_PostfixExpressionSuffixArgument(context, (PostfixExpressionSuffixArgument) semanticObject); 
				return; 
			case ParserPackage.POSTFIX_EXPRESSION_SUFFIX_ARRAY:
				sequence_PostfixExpressionSuffixArray(context, (PostfixExpressionSuffixArray) semanticObject); 
				return; 
			case ParserPackage.POSTFIX_EXPRESSION_SUFFIX_ARROW:
				sequence_PostfixExpressionSuffixArrow(context, (PostfixExpressionSuffixArrow) semanticObject); 
				return; 
			case ParserPackage.POSTFIX_EXPRESSION_SUFFIX_DOT:
				sequence_PostfixExpressionSuffixDot(context, (PostfixExpressionSuffixDot) semanticObject); 
				return; 
			case ParserPackage.POSTFIX_EXPRESSION_SUFFIX_MINUS_MINUS:
				sequence_PostfixExpressionSuffixMinusMinus(context, (PostfixExpressionSuffixMinusMinus) semanticObject); 
				return; 
			case ParserPackage.POSTFIX_EXPRESSION_SUFFIX_PLUS_PLUS:
				sequence_PostfixExpressionSuffixPlusPlus(context, (PostfixExpressionSuffixPlusPlus) semanticObject); 
				return; 
			case ParserPackage.PRIMARY_EXPRESSION:
				sequence_PrimaryExpression(context, (PrimaryExpression) semanticObject); 
				return; 
			case ParserPackage.RELATIONAL_EXPRESSION:
				sequence_RelationalExpression(context, (RelationalExpression) semanticObject); 
				return; 
			case ParserPackage.SELECTION_STATEMENT:
				sequence_SelectionStatement(context, (SelectionStatement) semanticObject); 
				return; 
			case ParserPackage.SHIFT_EXPRESSION:
				sequence_ShiftExpression(context, (ShiftExpression) semanticObject); 
				return; 
			case ParserPackage.SPECIFIER_QUALIFIER_LIST:
				sequence_SpecifierQualifierList(context, (SpecifierQualifierList) semanticObject); 
				return; 
			case ParserPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case ParserPackage.STORAGE_CLASS_SPECIFIER:
				sequence_StorageClassSpecifier(context, (StorageClassSpecifier) semanticObject); 
				return; 
			case ParserPackage.STRUCT_DECLARATION:
				sequence_StructDeclaration(context, (StructDeclaration) semanticObject); 
				return; 
			case ParserPackage.STRUCT_DECLARATION_LIST:
				sequence_StructDeclarationList(context, (StructDeclarationList) semanticObject); 
				return; 
			case ParserPackage.STRUCT_DECLARATOR:
				sequence_StructDeclarator(context, (StructDeclarator) semanticObject); 
				return; 
			case ParserPackage.STRUCT_DECLARATOR_LIST:
				sequence_StructDeclaratorList(context, (StructDeclaratorList) semanticObject); 
				return; 
			case ParserPackage.STRUCT_OR_UNION:
				sequence_StructOrUnion(context, (StructOrUnion) semanticObject); 
				return; 
			case ParserPackage.STRUCT_OR_UNION_SPECIFIER:
				sequence_StructOrUnionSpecifier(context, (StructOrUnionSpecifier) semanticObject); 
				return; 
			case ParserPackage.TYPE_NAME:
				sequence_TypeName(context, (TypeName) semanticObject); 
				return; 
			case ParserPackage.TYPE_QUALIFIER:
				sequence_TypeQualifier(context, (TypeQualifier) semanticObject); 
				return; 
			case ParserPackage.TYPE_QUALIFIER_LIST:
				sequence_TypeQualifierList(context, (TypeQualifierList) semanticObject); 
				return; 
			case ParserPackage.TYPE_SPECIFIER:
				sequence_TypeSpecifier(context, (TypeSpecifier) semanticObject); 
				return; 
			case ParserPackage.TYPEDEF_NAME:
				sequence_TypedefName(context, (TypedefName) semanticObject); 
				return; 
			case ParserPackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             (typeQualifierList=TypeQualifierList? assignmentExpr+=AssignmentExpression?) | 
	 *             (typeQualifierList=TypeQualifierList? assignmentExpr+=AssignmentExpression) | 
	 *             (typeQualifierListOrig=TypeQualifierList assignmentExpr+=AssignmentExpression) | 
	 *             (parameterTypeList=ParameterTypeList? gccDeclExt+=GccDeclaratorExtension*)
	 *         )?
	 *     )
	 */
	protected void sequence_AbstractDeclaratorSuffix(EObject context, AbstractDeclaratorSuffix semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (pointer=Pointer | (pointer=Pointer? directAbstractDeclarator=DirectAbstractDeclarator gccDeclExtAbstract+=GccDeclaratorExtension*))
	 */
	protected void sequence_AbstractDeclarator(EObject context, AbstractDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=AdditiveExpression_AdditiveExpression_1_0 (op=SKW_PLUS | op=SKW_MINUS) right=MultiplicativeExpression)
	 */
	protected void sequence_AdditiveExpression(EObject context, AdditiveExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=AndExpression_AndExpression_1_0 right=EqualityExpression)
	 */
	protected void sequence_AndExpression(EObject context, AndExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.EXPRESSION__LEFT));
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.EXPRESSION__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRightEqualityExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (expr+=AssignmentExpression expr+=AssignmentExpression*)
	 */
	protected void sequence_ArgumentExpressionList(EObject context, ArgumentExpressionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (asmLine=AsmLineWithoutColon?)
	 */
	protected void sequence_AsmLineWithColon(EObject context, AsmLineWithColon semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (asmLines+=AsmLine asmLines+=AsmLine*)
	 */
	protected void sequence_AsmLineWithoutColon(EObject context, AsmLineWithoutColon semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (sym=AsmSymbolicName? expr=LogicalOrExpression)
	 */
	protected void sequence_AsmLine(EObject context, AsmLine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (asm=KW_ASM1 | asm=KW_ASM2 | asm=KW_ASM3) 
	 *         (volatile=KW_VOLATILE | volatile=KW_VOLATILE2)? 
	 *         asmLine1=AsmLine? 
	 *         asmLines+=AsmLineWithColon* 
	 *         lastComma?=SKW_COMMA?
	 *     )
	 */
	protected void sequence_AsmStatement(EObject context, AsmStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_AsmSymbolicName(EObject context, AsmSymbolicName semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.ASM_SYMBOLIC_NAME__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.ASM_SYMBOLIC_NAME__ID));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAsmSymbolicNameAccess().getIdIDTerminalRuleCall_2_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (expr=Lvalue op=AssignmentOperator assignmentExpr=AssignmentExpression)
	 */
	protected void sequence_AssignmentExpression(EObject context, AssignmentExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (declaration+=Declaration | statement+=Statement)+
	 */
	protected void sequence_BlockList(EObject context, BlockList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (blockList+=BlockList?)
	 */
	protected void sequence_BodyStatement(EObject context, BodyStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=TypeName expr=CastExpression)
	 */
	protected void sequence_CastExpression(EObject context, CastExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     body=BodyStatement
	 */
	protected void sequence_CompoundStatement(EObject context, CompoundStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (left=ConditionalExpression_ConditionalExpression_1_0 qExpr=Expression? cExpr=ConditionalExpression) | 
	 *         (left=ConditionalExpression_ConditionalExpression_1_0 cExpr=ConditionalExpression)
	 *     )
	 */
	protected void sequence_ConditionalExpression(EObject context, ConditionalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         declarationSpecifier+=StorageClassSpecifier | 
	 *         declarationSpecifier+=TypeSpecifier | 
	 *         declarationSpecifier+=TypeQualifier | 
	 *         declarationSpecifier+=FunctionSpecifier
	 *     )+
	 */
	protected void sequence_DeclarationSpecifiers(EObject context, DeclarationSpecifiers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (specifiers=DeclarationSpecifiers initDeclaratorList+=InitDeclaratorList?)
	 */
	protected void sequence_Declaration(EObject context, Declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((expr=AssignmentExpression | lastSuffix=DirectDeclaratorLastSuffix)?)
	 */
	protected void sequence_DeclaratorSuffix(EObject context, DeclaratorSuffix semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (pointer=Pointer? gccDeclExt1+=GccDeclaratorExtension* declarator=DirectDeclarator gccDeclExt2+=GccDeclaratorExtension*)
	 */
	protected void sequence_Declarator(EObject context, Declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     list=DesignatorList
	 */
	protected void sequence_Designation(EObject context, Designation semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.DESIGNATION__LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.DESIGNATION__LIST));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDesignationAccess().getListDesignatorListParserRuleCall_1_0(), semanticObject.getList());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (designator+=Designator designator+=Designator*)
	 */
	protected void sequence_DesignatorList(EObject context, DesignatorList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((expr=ConstantExpression to=ConstantExpression?) | id=ID)
	 */
	protected void sequence_Designator(EObject context, Designator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         ((declarator=AbstractDeclarator gccDeclExt+=GccDeclaratorExtension*) | abstractDeclaratorSuffix+=AbstractDeclaratorSuffix) 
	 *         abstractDeclaratorSuffix+=AbstractDeclaratorSuffix*
	 *     )
	 */
	protected void sequence_DirectAbstractDeclarator(EObject context, DirectAbstractDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (parameterTypeList+=ParameterTypeList | identifierList=IdentifierList?)
	 */
	protected void sequence_DirectDeclaratorLastSuffix(EObject context, DirectDeclaratorLastSuffix semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((id=ID | declarator=Declarator) declaratorSuffix+=DeclaratorSuffix*)
	 */
	protected void sequence_DirectDeclarator(EObject context, DirectDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (enumList=EnumeratorList | (id=ID enumList=EnumeratorList?))
	 */
	protected void sequence_EnumSpecifier(EObject context, EnumSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (enumerator+=Enumerator enumerator+=Enumerator* lastComma?=SKW_COMMA?)
	 */
	protected void sequence_EnumeratorList(EObject context, EnumeratorList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id=ID expr=ConstantExpression?)
	 */
	protected void sequence_Enumerator(EObject context, Enumerator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=EqualityExpression_EqualityExpression_1_0 (op=SKW_EQUAL | op=SKW_NOTEQUAL) right=RelationalExpression)
	 */
	protected void sequence_EqualityExpression(EObject context, EqualityExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=ExclusiveOrExpression_ExclusiveOrExpression_1_0 right=AndExpression)
	 */
	protected void sequence_ExclusiveOrExpression(EObject context, ExclusiveOrExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.EXPRESSION__LEFT));
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.EXPRESSION__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExclusiveOrExpressionAccess().getExclusiveOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExclusiveOrExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (expression=Expression?)
	 */
	protected void sequence_ExpressionStatement(EObject context, ExpressionStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=Expression_Expression_1_0 right=AssignmentExpression)
	 */
	protected void sequence_Expression(EObject context, Expression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.EXPRESSION__LEFT));
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.EXPRESSION__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExpressionAccess().getExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionAccess().getRightAssignmentExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((functiondefHead=FunctionDefHead functionDefinition=FunctionDefinition) | declaration=Declaration | semi=SKW_SEMI)
	 */
	protected void sequence_ExternalDeclaration(EObject context, ExternalDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         declarationSpecifier+=StorageClassSpecifier | 
	 *         declarationSpecifier+=TypeSpecifier | 
	 *         declarationSpecifier+=TypeQualifier | 
	 *         declarationSpecifier+=FunctionSpecifier
	 *     )+
	 */
	protected void sequence_FunctionDeclarationSpecifiers(EObject context, FunctionDeclarationSpecifiers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (funDeclSpecifiers=FunctionDeclarationSpecifiers? funDeclarator=Declarator funDeclaration+=Declaration*)
	 */
	protected void sequence_FunctionDefHead(EObject context, FunctionDefHead semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     body=BodyStatement
	 */
	protected void sequence_FunctionDefinition(EObject context, FunctionDefinition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.FUNCTION_DEFINITION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.FUNCTION_DEFINITION__BODY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFunctionDefinitionAccess().getBodyBodyStatementParserRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=KW_INLINE1 | name=KW_INLINE2 | name=KW_INLINE3 | name=KW_NORETURN | gccAttributeSpecifier=GccAttributeSpecifier)
	 */
	protected void sequence_FunctionSpecifier(EObject context, FunctionSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (gccAttribute+=GccAttribute gccAttribute+=GccAttribute*)
	 */
	protected void sequence_GccAttributeList(EObject context, GccAttributeList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((attribute=KW_ATTRIBUTE2 | attribute=KW_ATTRIBUTE3) list=GccAttributeList?)
	 */
	protected void sequence_GccAttributeSpecifier(EObject context, GccAttributeSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((id=ID | const=Constant1 | keyword=ParserKeywords) list=ArgumentExpressionList?)
	 */
	protected void sequence_GccAttribute(EObject context, GccAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (((asm=KW_ASM1 | asm=KW_ASM2 | asm=KW_ASM3) string+=STRING_LITERAL+) | gccAttributeSpecifier=GccAttributeSpecifier)
	 */
	protected void sequence_GccDeclaratorExtension(EObject context, GccDeclaratorExtension semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id+=MyIdentifier id+=MyIdentifier*)
	 */
	protected void sequence_IdentifierList(EObject context, IdentifierList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=InclusiveOrExpression_InclusiveOrExpression_1_0 right=ExclusiveOrExpression)
	 */
	protected void sequence_InclusiveOrExpression(EObject context, InclusiveOrExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.EXPRESSION__LEFT));
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.EXPRESSION__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInclusiveOrExpressionAccess().getInclusiveOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getInclusiveOrExpressionAccess().getRightExclusiveOrExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (initDeclarator+=InitDeclarator initDeclarator+=InitDeclarator*)
	 */
	protected void sequence_InitDeclaratorList(EObject context, InitDeclaratorList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (declarator=Declarator initializer=Initializer?)
	 */
	protected void sequence_InitDeclarator(EObject context, InitDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (designation=Designation? initializer=Initializer)
	 */
	protected void sequence_Init(EObject context, Init semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (init+=Init init+=Init*)
	 */
	protected void sequence_InitializerList(EObject context, InitializerList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expr=AssignmentExpression | (list=InitializerList? lastComma?=SKW_COMMA?))
	 */
	protected void sequence_Initializer(EObject context, Initializer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (while=KW_WHILE expr=Expression statement=Statement) | 
	 *         (do=KW_DO statement=Statement expr=Expression semi=SKW_SEMI) | 
	 *         (for=KW_FOR initExpr=Expression? expr=Expression? incExpr=Expression? statement=Statement) | 
	 *         (for=KW_FOR initDecl=Declaration expr=Expression? incExpr=Expression? statement=Statement)
	 *     )
	 */
	protected void sequence_IterationStatement(EObject context, IterationStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (continue=KW_CONTINUE | break=KW_BREAK | (return=KW_RETURN expr=Expression?) | (goto=KW_GOTO expr=UnaryExpression))
	 */
	protected void sequence_JumpStatement(EObject context, JumpStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (id=ID lStmt=Statement) | 
	 *         (case=KW_CASE ((lower=Constant1 higher=Constant1) | expr=ConstantExpression) lStmt=Statement) | 
	 *         (mydefault?=KW_DEFAULT lStmt=Statement)
	 *     )
	 */
	protected void sequence_LabeledStatement(EObject context, LabeledStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=LogicalAndExpression_LogicalAndExpression_1_0 right=InclusiveOrExpression)
	 */
	protected void sequence_LogicalAndExpression(EObject context, LogicalAndExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.EXPRESSION__LEFT));
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.EXPRESSION__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLogicalAndExpressionAccess().getLogicalAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicalAndExpressionAccess().getRightInclusiveOrExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=LogicalOrExpression_LogicalOrExpression_1_0 right=LogicalAndExpression)
	 */
	protected void sequence_LogicalOrExpression(EObject context, LogicalOrExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.EXPRESSION__LEFT));
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.EXPRESSION__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLogicalOrExpressionAccess().getLogicalOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicalOrExpressionAccess().getRightLogicalAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=MultiplicativeExpression_MultiplicativeExpression_1_0 (op=SKW_STAR | op=SKW_DIV | op=SKW_MOD) right=CastExpression)
	 */
	protected void sequence_MultiplicativeExpression(EObject context, MultiplicativeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_MyIdentifier(EObject context, MyIdentifier semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.MY_IDENTIFIER__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.MY_IDENTIFIER__ID));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMyIdentifierAccess().getIdIDTerminalRuleCall_1_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (declSpecifiers=DeclarationSpecifiers (declarator=Declarator | abstractDeclator=AbstractDeclarator?))
	 */
	protected void sequence_ParameterDeclaration(EObject context, ParameterDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (parameterDeclaration+=ParameterDeclaration parameterDeclaration+=ParameterDeclaration*)
	 */
	protected void sequence_ParameterList(EObject context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (list=ParameterList ellipsis?=Ellipsis?)
	 */
	protected void sequence_ParameterTypeList(EObject context, ParameterTypeList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (external+=ExternalDeclaration*)
	 */
	protected void sequence_Parser(EObject context, Parser semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (((star+=SKW_STAR | caret+=SKW_CARET) typeQualifierList+=TypeQualifierList?)*)
	 */
	protected void sequence_Pointer(EObject context, Pointer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (argumentExpressionList=ArgumentExpressionList?)
	 */
	protected void sequence_PostfixExpressionSuffixArgument(EObject context, PostfixExpressionSuffixArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     arrayExpr=Expression
	 */
	protected void sequence_PostfixExpressionSuffixArray(EObject context, PostfixExpressionSuffixArray semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.POSTFIX_EXPRESSION_SUFFIX_ARRAY__ARRAY_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.POSTFIX_EXPRESSION_SUFFIX_ARRAY__ARRAY_EXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPostfixExpressionSuffixArrayAccess().getArrayExprExpressionParserRuleCall_2_0(), semanticObject.getArrayExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_PostfixExpressionSuffixArrow(EObject context, PostfixExpressionSuffixArrow semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.POSTFIX_EXPRESSION_SUFFIX_ARROW__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.POSTFIX_EXPRESSION_SUFFIX_ARROW__ID));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPostfixExpressionSuffixArrowAccess().getIdIDTerminalRuleCall_2_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_PostfixExpressionSuffixDot(EObject context, PostfixExpressionSuffixDot semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.POSTFIX_EXPRESSION_SUFFIX_DOT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.POSTFIX_EXPRESSION_SUFFIX_DOT__ID));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPostfixExpressionSuffixDotAccess().getIdIDTerminalRuleCall_2_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {PostfixExpressionSuffixMinusMinus}
	 */
	protected void sequence_PostfixExpressionSuffixMinusMinus(EObject context, PostfixExpressionSuffixMinusMinus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {PostfixExpressionSuffixPlusPlus}
	 */
	protected void sequence_PostfixExpressionSuffixPlusPlus(EObject context, PostfixExpressionSuffixPlusPlus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             expr=PostfixExpression_PostfixExpression_1_0 
	 *             (
	 *                 suffix=PostfixExpressionSuffixArray | 
	 *                 suffix=PostfixExpressionSuffixArgument | 
	 *                 suffix=PostfixExpressionSuffixDot | 
	 *                 suffix=PostfixExpressionSuffixArrow | 
	 *                 suffix=PostfixExpressionSuffixPlusPlus | 
	 *                 suffix=PostfixExpressionSuffixMinusMinus
	 *             )
	 *         ) | 
	 *         (ext?=KW_EXTENSION? typeName=TypeName initializerList=InitializerList comma?=SKW_COMMA?)
	 *     )
	 */
	protected void sequence_PostfixExpression(EObject context, PostfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         id=ID | 
	 *         const=Constant2 | 
	 *         string+=STRING_LITERAL+ | 
	 *         (parentheses?=SKW_LEFTPAREN expr=Expression) | 
	 *         (ext?=KW_EXTENSION? compoundStmt=CompoundStatement) | 
	 *         (builtin_offsetof?=KW_BUILTIN_OFFSETOF typeName=TypeName expr=UnaryExpression) | 
	 *         (builtin_typescompatiblep?=KW_BUILTIN_TYPESCOMPATIBLEP typeName=TypeName typeName2=TypeName)
	 *     )
	 */
	protected void sequence_PrimaryExpression(EObject context, PrimaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         left=RelationalExpression_RelationalExpression_1_0 
	 *         (op=SKW_LESS | op=SKW_GREATER | op=SKW_LESSEQUAL | op=SKW_GREATEREQUAL) 
	 *         right=ShiftExpression
	 *     )
	 */
	protected void sequence_RelationalExpression(EObject context, RelationalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (if=KW_IF expr=Expression ifStatement=Statement (else=KW_ELSE elseStatement=Statement)?) | 
	 *         (switch=KW_SWITCH expr=Expression switchStatement=Statement)
	 *     )
	 */
	protected void sequence_SelectionStatement(EObject context, SelectionStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=ShiftExpression_ShiftExpression_1_0 (op=SKW_LEFTSHIFT | op=SKW_RIGHTSHIFT) right=AdditiveExpression)
	 */
	protected void sequence_ShiftExpression(EObject context, ShiftExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (typeSpecifier+=TypeSpecifier | typeQualifier+=TypeQualifier)+
	 */
	protected void sequence_SpecifierQualifierList(EObject context, SpecifierQualifierList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         stmt=LabeledStatement | 
	 *         stmt=CompoundStatement | 
	 *         stmt=ExpressionStatement | 
	 *         stmt=SelectionStatement | 
	 *         stmt=IterationStatement | 
	 *         stmt=JumpStatement | 
	 *         stmt=AsmStatement
	 *     )
	 */
	protected void sequence_Statement(EObject context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=KW_TYPEDEF | 
	 *         name=KW_EXTERN | 
	 *         name=KW_STATIC | 
	 *         name=KW_THREADLOCAL | 
	 *         name=KW_AUTO | 
	 *         name=KW_REGISTER | 
	 *         name=KW_LABEL3
	 *     )
	 */
	protected void sequence_StorageClassSpecifier(EObject context, StorageClassSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     structDeclaration+=StructDeclaration+
	 */
	protected void sequence_StructDeclarationList(EObject context, StructDeclarationList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((list=SpecifierQualifierList structDeclarationList=StructDeclaratorList?)?)
	 */
	protected void sequence_StructDeclaration(EObject context, StructDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (structDeclarator+=StructDeclarator structDeclarator+=StructDeclarator*)
	 */
	protected void sequence_StructDeclaratorList(EObject context, StructDeclaratorList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((declarator=Declarator constExpr+=ConstantExpression?) | constExpr+=ConstantExpression)
	 */
	protected void sequence_StructDeclarator(EObject context, StructDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=StructOrUnion ((id=ID? braces?=SKW_LEFTBRACE structDeclList=StructDeclarationList?) | id=ID))
	 */
	protected void sequence_StructOrUnionSpecifier(EObject context, StructOrUnionSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=KW_STRUCT
	 */
	protected void sequence_StructOrUnion(EObject context, StructOrUnion semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.STRUCT_OR_UNION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.STRUCT_OR_UNION__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStructOrUnionAccess().getNameKW_STRUCTTerminalRuleCall_0_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (list=SpecifierQualifierList abstractDeclarator=AbstractDeclarator?)
	 */
	protected void sequence_TypeName(EObject context, TypeName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     typeQualifier+=TypeQualifier+
	 */
	protected void sequence_TypeQualifierList(EObject context, TypeQualifierList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         type=KW_CONST | 
	 *         type=KW_RESTRICT | 
	 *         type=KW_RESTRICT2 | 
	 *         type=KW_RESTRICT3 | 
	 *         type=KW_VOLATILE | 
	 *         type=KW_ATOMIC
	 *     )
	 */
	protected void sequence_TypeQualifier(EObject context, TypeQualifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=KW_BOOL
	 */
	protected void sequence_TypeSpecifier(EObject context, TypeSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_TypedefName(EObject context, TypedefName semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ParserPackage.Literals.TYPEDEF_NAME__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ParserPackage.Literals.TYPEDEF_NAME__ID));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTypedefNameAccess().getIdIDTerminalRuleCall_1_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (plusplus=SKW_PLUSPLUS expr=UnaryExpression) | 
	 *         (minusminus=SKW_MINUSMINUS expr=UnaryExpression) | 
	 *         (op=UnaryOperator expr=CastExpression) | 
	 *         (sizeOf=KW_SIZEOF typeName=TypeName) | 
	 *         (sizeOf=KW_SIZEOF expr=UnaryExpression) | 
	 *         ((alignOf=KW_ALIGNOF1 | alignOf=KW_ALIGNOF2 | alignOf=KW_ALIGNOF3) typeName=TypeName) | 
	 *         ((alignOf=KW_ALIGNOF1 | alignOf=KW_ALIGNOF2 | alignOf=KW_ALIGNOF3) expr=UnaryExpression) | 
	 *         (andand=SKW_ANDAND id=ID)
	 *     )
	 */
	protected void sequence_UnaryExpression(EObject context, UnaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
