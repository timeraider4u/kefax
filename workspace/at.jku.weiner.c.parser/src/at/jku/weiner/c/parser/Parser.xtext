/*
 [The "BSD licence"]
 Copyright (c) 2016 Harald Weiner

 Copyright (c) 2013 Sam Harwell
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
	notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
	notice, this list of conditions and the following disclaimer in the
	documentation and/or other materials provided with the distribution.
 3. The name of the author may not be used to endorse or promote products
	derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

grammar at.jku.weiner.c.parser.Parser
with at.jku.weiner.c.common.Common 
hidden(LINEDIRECTIVE,LINE_COMMENT,BLOCK_COMMENT,NEWLINE,WHITESPACE)

import "http://www.jku.at/weiner/c/common/Common" as common
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate parser "http://www.jku.at/weiner/c/parser/Parser"

/*** parser ***/

//Model returns common::Model: 
//	{common::Model} 
//	(units+=TranslationUnit)
//;
//
//TranslationUnit returns common::TranslationUnit:
//	{common::TranslationUnit}
//	parser=Parser
//;

Parser returns common::Parser
	initRuleAction{
		at.jku.weiner.c.parser.Scope.createNewScope("Parser");
	}
	afterRuleAction{
		at.jku.weiner.c.parser.Scope.removeScope(0);
	}
	:
	{Parser}
	(external+=ExternalDeclaration)*
;

ExternalDeclaration:
	{ExternalDeclaration}
	(
		(
			(=>
				functiondefHead=FunctionDefHead 
				SKW_LEFTBRACE
			)
			functionDefinition=FunctionDefinition
			SKW_RIGHTBRACE
		)
	|	declaration=Declaration
	|	semi=SKW_SEMI
	)
;

FunctionDefHead:
	{FunctionDefHead}
	(funDeclSpecifiers=FunctionDeclarationSpecifiers)? 
	funDeclarator=Declarator
	(funDeclaration+=Declaration)*
;

FunctionDefinition
	initRuleAction{
		at.jku.weiner.c.parser.Scope.createNewScope("FunctionDefinition");
	} 
	afterRuleAction{
		at.jku.weiner.c.parser.Scope.removeScope();
	}
	:
	{FunctionDefinition}
	body=BodyStatement
;


//
// ambiguity:
// 1.)declarationSpecifiers->declarationSpecifier->typeSpecifier->typedefName->IDENTIFIER
// 2.)initDeclaratorList->initDeclarator->declarator->directDeclarator->IDENTIFIER
Declaration
	initRuleAction{
		at.jku.weiner.c.parser.Scope.setTypedef(false);
	}
	:
	{Declaration}
	(
		specifiers=DeclarationSpecifiers 
		(initDeclaratorList+=InitDeclaratorList)? 
		semi=SKW_SEMI
	//|	staticAssertDeclaration
	)
;

FunctionDeclarationSpecifiers:
	{FunctionDeclarationSpecifiers}
	 
	(declarationSpecifier+=StorageClassSpecifier
	|	declarationSpecifier+=TypeSpecifier
	|	declarationSpecifier+=TypeQualifier
	|	declarationSpecifier+=FunctionSpecifier
	//|	declarationSpecifier+=alignmentSpecifier
	)+
;

DeclarationSpecifiers:
	{DeclarationSpecifiers}
	 
	(declarationSpecifier+=StorageClassSpecifier
	|	declarationSpecifier+=TypeSpecifier
	|	declarationSpecifier+=TypeQualifier
	|	declarationSpecifier+=StructOrUnionSpecifier
	|	declarationSpecifier+=FunctionSpecifier
	//|	declarationSpecifier+=alignmentSpecifier
	)+
;

InitDeclaratorList:
	{InitDeclaratorList}
	
	initDeclarator+=InitDeclarator
	(SKW_COMMA initDeclarator+=InitDeclarator)*
;

InitDeclarator:
	{InitDeclarator}
	
	declarator=Declarator
	(SKW_ASSIGN initializer=Initializer)?
;

StorageClassSpecifier:
	{StorageClassSpecifier}
	(	name=KW_TYPEDEF
			postAction{{ at.jku.weiner.c.parser.Scope.setTypedef(true);  }}
	|	name=KW_EXTERN
	|	name=KW_STATIC
	|	name=KW_THREADLOCAL
	|	name=KW_AUTO
	|	name=KW_REGISTER
	)
;

TypeSpecifier:
	{TypeSpecifier}
		name=KW_BOOL
	|	name=KW_BUILTIN_VA_LIST
	|	name=KW_CHAR
	|	name=KW_COMPLEX
	|	name=KW_DOUBLE
	|	name=KW_FLOAT
	|	name=KW_INT
	|	name=KW_LONG
	|	name=KW_SHORT
	|	name=KW_M128
	|	name=KW_M128D
	|	name=KW_M128I
	|	name=KW_SIGNED1
	|	name=KW_SIGNED2
	|	name=KW_SIGNED3
	|	name=KW_UNSIGNED
	|	name=KW_VOID
	

	|	name=KW_EXTENSION (SKW_LEFTPAREN 
			(extType=KW_M128 | extType=KW_M128D | extType=KW_M128I) 
			SKW_RIGHTPAREN)?
	//  |	specifier=atomicTypeSpecifier
	//|	specifier=StructOrUnionSpecifier
	|	specifier=EnumSpecifier
	|	type=TypedefName
	|	struct=StructOrUnionName
	// |	'__typeof__' LEFTPAREN constExrp=constantExpression RIGHTPAREN // GCC extension
;

TypedefName:
	{TypedefName}
	id=ID
		preAction{ { at.jku.weiner.c.parser.Scope.isTypeName(input.LT(1).getText()) }? }
;

StructOrUnionName:
	{StructOrUnionName}
	id=ID
		preAction{ { at.jku.weiner.c.parser.Scope.isStructName(input.LT(1).getText()) }? }
;

StructOrUnionSpecifier returns DeclarationSpecifier
	// structs are scopes
	initRuleAction {
		at.jku.weiner.c.parser.Scope.createNewScope("StructOrUnion");
	}
	afterRuleAction {
		at.jku.weiner.c.parser.Scope.removeScope();
	}
	:
	{StructOrUnionSpecifier}
	type=StructOrUnion
	(	(id=ID)? SKW_LEFTBRACE structDeclList=StructDeclarationList SKW_RIGHTBRACE
		preAction{ {
			at.jku.weiner.c.parser.Scope.setTemp(input);
		} }
		postAction{ {
			at.jku.weiner.c.parser.Scope.addStructOrUnion();
		} }
	|	id=ID
		preAction{ {
			at.jku.weiner.c.parser.Scope.setTemp(input);
		} }
		postAction{ {
			at.jku.weiner.c.parser.Scope.addStructOrUnion();
		} }
	)
;

StructOrUnion:
	{StructOrUnion}
		name=KW_STRUCT
	|	name=KW_UNION
;

StructDeclarationList: (structDeclaration+=StructDeclaration)+;

StructDeclaration:
	list=SpecifierQualifierList (structDeclarationList=StructDeclaratorList)? SKW_SEMI
	//|	staticAssertDeclaration
;

SpecifierQualifierList:
	{SpecifierQualifierList} 
	(typeSpecifier+=TypeSpecifier | typeQualifier+=TypeQualifier| 
		structOrUnionSpecifier+=StructOrUnionSpecifier
	)+
;

StructDeclaratorList: structDeclarator+=StructDeclarator (SKW_COMMA structDeclarator+=StructDeclarator)*;

StructDeclarator: declarator=Declarator (SKW_COLON constExpr+=ConstantExpression)?
	| (SKW_COLON constExpr+=ConstantExpression)
;

EnumSpecifier returns DeclarationSpecifier:
	{EnumSpecifier} 
	(	
		KW_ENUM
		(	SKW_LEFTBRACE enumList=EnumeratorList SKW_RIGHTBRACE
		|	id=ID (SKW_LEFTBRACE enumList=EnumeratorList SKW_RIGHTBRACE)?
		)
	)
;

EnumeratorList: enumerator+=Enumerator
	(SKW_COMMA enumerator+=Enumerator)*
;

Enumerator:
	{Enumerator} 
	id=ID
	(SKW_ASSIGN expr=ConstantExpression)?
;

/*
atomicTypeSpecifier returns declarationSpecifier:
	ATOMIC LEFTPAREN typeName RIGHTPAREN
;
*/

TypeQualifier:
	{TypeQualifier} 
	(	type=KW_CONST
	|	type=KW_RESTRICT
	|	type=KW_RESTRICT2
	|	type=KW_RESTRICT3
	|	type=KW_VOLATILE
	|	type=KW_ATOMIC
	)
;

FunctionSpecifier:
	{FunctionSpecifier} 
	(
		(
			name=KW_INLINE1
			|	name=KW_INLINE2 // GCC extension	
			|	name=KW_NORETURN
			//|	'__stdcall'
		)
		
		|	gccAttributeSpecifier=GccAttributeSpecifier
		//|	'__declspec' LEFTPAREN IDENTIFIER RIGHTPAREN
	)
;

/*
alignmentSpecifier: ALIGNAS LEFTPAREN (typeName | constantExpression) RIGHTPAREN;
*/

Declarator:
	{Declarator}	
	(pointer=Pointer)?
	(declarator=DirectDeclarator)
	(gccDeclExt+=GccDeclaratorExtension)*
;

DirectDeclarator:
	{DirectDeclarator}
	(id=ID
		preAction{ {
			at.jku.weiner.c.parser.Scope.setTemp(input);
		} }
		postAction{ {
			at.jku.weiner.c.parser.Scope.addTypedefIfIsTypedef();
		} }
	| SKW_LEFTPAREN declarator=Declarator SKW_RIGHTPAREN
	)
	(declaratorSuffix+=DeclaratorSuffix)*	
;

DeclaratorSuffix:
	{DeclaratorSuffix}
	(
		SKW_LEFTBRACKET  (typeQualifierList=TypeQualifierList)?
			(expr=AssignmentExpression)? SKW_RIGHTBRACKET
	|	SKW_LEFTBRACKET static=KW_STATIC (typeQualifierList=TypeQualifierList)?
			(expr=AssignmentExpression) SKW_RIGHTBRACKET
	|	SKW_LEFTBRACKET (typeQualifierList=TypeQualifierList) static=KW_STATIC
			(expr=AssignmentExpression) SKW_RIGHTBRACKET
	|	SKW_LEFTBRACKET (typeQualifierList=TypeQualifierList)? star=SKW_STAR SKW_RIGHTBRACKET
	|	lastSuffix=DirectDeclaratorLastSuffix
	)
;

DirectDeclaratorLastSuffix:
	{DirectDeclaratorLastSuffix}
	 SKW_LEFTPAREN
		(
			(parameterTypeList+=ParameterTypeList)
			|
			(identifierList=IdentifierList)?
		)
	SKW_RIGHTPAREN
;


GccDeclaratorExtension:
	{GccDeclaratorExtension}
	(
			asm=(KW_ASM1|KW_ASM2|KW_ASM3) SKW_LEFTPAREN string+=STRING_LITERAL+ SKW_RIGHTPAREN
		|	gccAttributeSpecifier=GccAttributeSpecifier
	)
;


GccAttributeSpecifier:
	{GccAttributeSpecifier} 
	KW_ATTRIBUTE SKW_LEFTPAREN SKW_LEFTPAREN 
		(list=GccAttributeList)? 
	SKW_RIGHTPAREN SKW_RIGHTPAREN
;

GccAttributeList: 
		gccAttribute+=GccAttribute 
		(SKW_COMMA gccAttribute+=GccAttribute)*
;


GccAttribute: {GccAttribute}
	(
			id=ID
		|	const = Constant1
	)
	(SKW_LEFTPAREN list=ArgumentExpressionList? SKW_RIGHTPAREN)?
;

///* */
//nestedParenthesesBlock: (	NOPAREN
//		|	LEFTPAREN nestedParenthesesBlock RIGHTPAREN
//		)*
//;
//*/


Pointer:
	{Pointer} 
	(
		((star+=SKW_STAR | caret+=SKW_CARET) typeQualifierList+=TypeQualifierList?)*
		//|	{pointer} CARET typeQualifierList=typeQualifierList? pointer=pointer?// Blocks language extension
	)
;

TypeQualifierList: {TypeQualifierList} (typeQualifier+=TypeQualifier)+;

ParameterTypeList:
	{ParameterTypeList}
	list=ParameterList
	(SKW_COMMA ellipsis?=Ellipsis)?
;

ParameterList:
	{ParameterList} 
	parameterDeclaration+=ParameterDeclaration
	(SKW_COMMA parameterDeclaration+=ParameterDeclaration)*
;

ParameterDeclaration:
	{ParameterDeclaration}
	declSpecifiers=DeclarationSpecifiers
	(		
			declarator=Declarator
		|	(abstractDeclator=AbstractDeclarator)?
	)
;

IdentifierList:
	{IdentifierList} 
	id+=MyIdentifier (SKW_COMMA id+=MyIdentifier)*
;

MyIdentifier:
	{MyIdentifier}
	id=ID
;

TypeName:
	{TypeName}
	list=SpecifierQualifierList 
	(abstractDeclarator=AbstractDeclarator)?
;


AbstractDeclarator:
	{AbstractDeclarator}
	(
	pointer=Pointer
	//(directAbstractDeclarator=DirectAbstractDeclarator)?
	//(gccDeclExtAbstract+=gccDeclaratorExtension)*
	//| 
	//(directAbstractDeclarator=DirectAbstractDeclarator)?
	//(gccDeclExtAbstract+=gccDeclaratorExtension)*
	)
;


//DirectAbstractDeclarator returns AbstractDeclarator:
//	{DirectAbstractDeclarator}
//	(SKW_LEFTPAREN declarator=AbstractDeclarator SKW_RIGHTPAREN
//		//(gccDeclExt+=gccDeclaratorExtension)*
//	|	abstractDeclaratorSuffix+=AbstractDeclaratorSuffix
//	)
//	
//	//(abstractDeclaratorSuffix+=abstractDeclaratorSuffix)*
//;



//AbstractDeclaratorSuffix:
//	{AbstractDeclaratorSuffix}
//	(SKW_LEFTBRACKET typeQualifierList=TypeQualifierList? (assignmentExpr+=AssignmentExpression)? SKW_RIGHTBRACKET
//	|	SKW_LEFTBRACKET KW_STATIC typeQualifierList=TypeQualifierList? (assignmentExpr+=AssignmentExpression) SKW_RIGHTBRACKET
//	|	SKW_LEFTBRACKET typeQualifierListOrig=TypeQualifierList KW_STATIC assignmentExpr+=AssignmentExpression SKW_RIGHTBRACKET
//	|	SKW_LEFTBRACKET SKW_STAR SKW_RIGHTBRACKET
//	//|	SKW_LEFTPAREN parameterTypeList=ParameterTypeList? SKW_RIGHTPAREN (gccDeclExt+=gccDeclaratorExtension)*
//	)
//;



Initializer:
	{Initializer}
	(
		expr=AssignmentExpression
	|	SKW_LEFTBRACE list=InitializerList SKW_COMMA? SKW_RIGHTBRACE
	)
;

InitializerList:
	{InitializerList}
	//designation+=Designation?
	(initializer+=Initializer)
	(SKW_COMMA 
		//(designation+=Designation)?
		(initializer+=Initializer)
	)*
;


/*** Statements */
BlockList:
	{BlockList}
	(declaration+=Declaration | statement+=Statement)+
;

Statement:
	{Statement}
	(
		stmt=LabeledStatement
	|	stmt=CompoundStatement
	|	stmt=ExpressionStatement
	|	stmt=SelectionStatement
	|	stmt=IterationStatement
	|	stmt=JumpStatement
	|	stmt=AsmStatement
	)
;

LabeledStatement returns Statement:
	{LabeledStatement}
	(
		id=ID SKW_COLON lStmt=Statement	
	|	case=KW_CASE expr=ConstantExpression SKW_COLON lStmt=Statement
	|	default=KW_DEFAULT SKW_COLON lStmt=Statement
	)
;

CompoundStatement returns Statement
	initRuleAction {
		at.jku.weiner.c.parser.Scope.createNewScope("CompoundStatement");
	}
	afterRuleAction {
		at.jku.weiner.c.parser.Scope.removeScope();
	}
	:
	{CompoundStatement}
	SKW_LEFTBRACE
		body=BodyStatement
	SKW_RIGHTBRACE
;

BodyStatement returns Statement:
	{BodyStatement}
	(blockList+=BlockList)?
;

ExpressionStatement returns Statement:
	{ExpressionStatement} 
	(expression = Expression)? 
	semi=SKW_SEMI
;

SelectionStatement returns Statement:
	{SelectionStatement}
	(
		if=KW_IF SKW_LEFTPAREN expr=Expression SKW_RIGHTPAREN ifStatement=Statement
		(=>else=KW_ELSE elseStatement=Statement)?
	|	switch=KW_SWITCH SKW_LEFTPAREN expr=Expression SKW_RIGHTPAREN switchStatement=Statement
	)
;

IterationStatement returns Statement:
	{IterationStatement}
	(
		while=KW_WHILE SKW_LEFTPAREN expr=Expression SKW_RIGHTPAREN statement=Statement
	|	do=KW_DO statement=Statement KW_WHILE SKW_LEFTPAREN expr=Expression SKW_RIGHTPAREN semi=SKW_SEMI
	|	for=KW_FOR SKW_LEFTPAREN initExpr=Expression? SKW_SEMI expr=Expression? SKW_SEMI incExpr=Expression? 
			SKW_RIGHTPAREN statement=Statement
	|	for=KW_FOR SKW_LEFTPAREN initDecl=Declaration (expr=Expression)? SKW_SEMI incExpr=Expression? 
			SKW_RIGHTPAREN statement=Statement
	)
;

JumpStatement returns Statement:
	{JumpStatement}
	(
		continue=KW_CONTINUE semi=SKW_SEMI
	|	break=KW_BREAK semi=SKW_SEMI
	|	return=KW_RETURN expr=Expression? semi=SKW_SEMI
	|	goto=KW_GOTO expr=UnaryExpression semi=SKW_SEMI // GCC extension
	//|	KW_GOTO id=ID semi=SEMI //(can be reached over GOTO unaryExpression)
	)
;

AsmStatement returns Statement:
	{AsmStatement}
	(asm=KW_ASM1 | asm=KW_ASM2 | asm=KW_ASM3) 
	(volatile=KW_VOLATILE | volatile=KW_VOLATILE2)? 
		SKW_LEFTPAREN
			(
				asmLine+=AsmLineWithColon
				(asmLine+=AsmLineWithComma)*
			)+
		SKW_RIGHTPAREN semi=SKW_SEMI
;

AsmLineWithColon returns AsmLine:
	{AsmLineWithColon}
	colon?=SKW_COLON? expr=LogicalOrExpression
;

AsmLineWithComma returns AsmLine:
	{AsmLineWithComma}
	SKW_COMMA expr=LogicalOrExpression
;

//designation: designatorList ASSIGN;

//designatorList: designator (designator+=designator)*;
/*
designator: {designator} LEFTBRACKET expr=constantExpression RIGHTBRACKET
	|	{designator} DOT IDENTIFIER
;
*/

//staticAssertDeclaration: STATICASSERT LEFTPAREN constantExpression COMMA STRINGLITERAL+ RIGHTPAREN SEMI;

/*
declarationList: 
	(declaration+=declaration)+
;
*/

/*** Expressions ***/
Expression:
	{Expression}
	exprExpr+=AssignmentExpression
	(SKW_COMMA exprExpr+=AssignmentExpression)*
;

AssignmentExpression returns Expression:
	{AssignmentExpression}
	(
		(
			expr=Lvalue
			op=AssignmentOperator
			assignmentExpr=AssignmentExpression
		)
	|
		expr=ConditionalExpression
	)
;

Lvalue returns Expression:
	UnaryExpression
;

AssignmentOperator:
	{AssignmentOperator}
	(
		op=SKW_ASSIGN
	| 	op=STARASSIGN
	| 	op=DIVASSIGN
	| 	op=MODASSIGN
	| 	op=PLUSASSIGN
	| 	op=MINUSASSIGN
	| 	op=LEFTSHIFTASSIGN
	| 	op=RIGHTSHIFTASSIGN
	| 	op=ANDASSIGN
	| 	op=XORASSIGN
	| 	op=ORASSIGN
	)
;

ConditionalExpression returns Expression:
	{ConditionalExpression}
	expr=LogicalOrExpression
	(SKW_QUESTION qExpr=Expression SKW_COLON
		cExpr=ConditionalExpression
	)?
;

LogicalOrExpression returns Expression:
	{LogicalOrExpression}
	expr+=LogicalAndExpression
	(SKW_OROR expr+=LogicalAndExpression)*
;

LogicalAndExpression returns Expression:
	{LogicalAndExpression}
	expr+=InclusiveOrExpression
	(SKW_ANDAND expr+=InclusiveOrExpression)*
;

InclusiveOrExpression returns Expression:
	{InclusiveOrExpression}
	expr+=ExclusiveOrExpression
	(SKW_OR expr+=ExclusiveOrExpression)*
;

ExclusiveOrExpression returns Expression:
	{ExclusiveOrExpression}
	expr+=AndExpression
	(SKW_CARET expr+=AndExpression)*
;

AndExpression returns Expression:
	{AndExpression}
	expr+=EqualityExpression
	(SKW_AND expr+=EqualityExpression)*
;

EqualityExpression returns Expression:
	{EqualityExpression}
	expr+=RelationalExpression
	((op+=SKW_EQUAL | op+=SKW_NOTEQUAL) expr+=RelationalExpression)*
;

RelationalExpression returns Expression:
	{RelationalExpression}
	expr+=ShiftExpression
	((op+=SKW_LESS|op+=SKW_GREATER|op+=SKW_LESSEQUAL|op+=SKW_GREATEREQUAL)
		expr += ShiftExpression
	)*
;

ShiftExpression returns Expression:
	{ShiftExpression}
	expr+=AdditiveExpression
	((op+=SKW_LEFTSHIFT| op+=SKW_RIGHTSHIFT)
		expr+=AdditiveExpression
	)*
;

AdditiveExpression returns Expression:
	{AdditiveExpression}
	expr+=MultiplicativeExpression
	((op+=SKW_PLUS| op+=SKW_MINUS)
		expr+=MultiplicativeExpression
	)*
;

MultiplicativeExpression returns Expression:
	{MultiplicativeExpression}
	expr+=CastExpression
	((op+=SKW_STAR|op+=SKW_DIV|op+=SKW_MOD)
		expr+=CastExpression
	)*
;

CastExpression returns Expression:
	{CastExpression}
	(
	expr=UnaryExpression
	|	SKW_LEFTPAREN type=TypeName SKW_RIGHTPAREN expr=CastExpression
	//|	'__extension__' SKW_LEFTPAREN type=TypeName SKW_RIGHTPAREN castExpr=CastExpression
	)
;

UnaryExpression returns Expression:
	{UnaryExpression}	
	(
		expr=PostfixExpression
	|	plusplus=SKW_PLUSPLUS expr=UnaryExpression
	|	minusminus=SKW_MINUSMINUS expr=UnaryExpression
	|	op=UnaryOperator expr=CastExpression
	|	sizeOf=KW_SIZEOF SKW_LEFTPAREN typeName=TypeName SKW_RIGHTPAREN
	|	sizeOf=KW_SIZEOF expr=UnaryExpression 
	//|	KW_ALIGNOF SKW_LEFTPAREN typeName=typeName SKW_RIGHTPAREN
	|	andand=SKW_ANDAND id=ID // GCC extension address of label
	)
;

UnaryOperator:
	{UnaryOperator}
	(
		op=SKW_AND
	|	op=SKW_STAR
	|	op=SKW_PLUS 
	|	op=SKW_MINUS 
	|	op=SKW_TILDE
	|	op=SKW_NOT
	)
;

PostfixExpression returns Expression:
	{PostfixExpression}
	(expr+=PrimaryExpression
	/*	(
	|	('__extension__' LEFTPAREN typeName RIGHTPAREN LEFTBRACE initializerList=initializerList) 
			(COMMA? RIGHTBRACE)
	)
	*/
	
	(
			suffix+=PostfixExpressionSuffixArray
		|	suffix+=PostfixExpressionSuffixArgument
		|	suffix+=PostfixExpressionSuffixDot
		|	suffix+=PostfixExpressionSuffixArrow
		|	suffix+=PostfixExpressionSuffixPlusPlus
		|	suffix+=PostfixExpressionSuffixMinusMinus
	)*
	
	)
;

PostfixExpressionSuffixArray returns PostfixExpressionSuffix:
	{PostfixExpressionSuffixArray}
	SKW_LEFTBRACKET arrayExpr=Expression SKW_RIGHTBRACKET
;

PostfixExpressionSuffixArgument returns PostfixExpressionSuffix:
	{PostfixExpressionSuffixArgument}
	SKW_LEFTPAREN (argumentExpressionList=ArgumentExpressionList)? SKW_RIGHTPAREN
;

PostfixExpressionSuffixDot returns PostfixExpressionSuffix:
	{PostfixExpressionSuffixDot}
	SKW_DOT id=ID
;

PostfixExpressionSuffixArrow returns PostfixExpressionSuffix:
	{PostfixExpressionSuffixArrow}
	ARROW id=ID
;

PostfixExpressionSuffixPlusPlus returns PostfixExpressionSuffix:
	{PostfixExpressionSuffixPlusPlus}
	SKW_PLUSPLUS
;

PostfixExpressionSuffixMinusMinus returns PostfixExpressionSuffix:
	{PostfixExpressionSuffixMinusMinus}
	SKW_MINUSMINUS
;

ArgumentExpressionList: expr+=AssignmentExpression (SKW_COMMA expr+=AssignmentExpression)*;

PrimaryExpression returns Expression:
	{PrimaryExpression}
	(id=ID
	|	const=Constant2
	//|	string+=STRING_LITERAL+ // reachable over Constant!
	|	SKW_LEFTPAREN expr=Expression SKW_RIGHTPAREN
	//|	genericSelection=genericSelection
	// |	'__extension__'? LEFTPAREN compoundStmt=compoundStatement RIGHTPAREN // Blocks (GCC extension)
	//|	'__builtin_va_arg' LEFTPAREN expr=unaryExpression COMMA typeName=typeName RIGHTPAREN
	//|	'__builtin_offsetof' LEFTPAREN typeName=typeName COMMA expr=unaryExpression RIGHTPAREN
	)
;

ConstantExpression returns Expression:
	{ConstantExpression}
	expr=ConditionalExpression
;

/*** UNKNOWN!!! ***/

//genericSelection: GENERIC LEFTPAREN assignmentExpression COMMA genericAssocList=genericAssocList RIGHTPAREN;

//genericAssocList: genericAssociation (COMMA genericAssociation+=genericAssociation)*;

/*
genericAssociation:
	(typeName | DEFAULT) COLON
	(assignmentExpression=assignmentExpression)
;
*/

/*** lexer ***/
/*** start with keywords ;-) */

terminal KW_ATOMIC : SKW_UNDERSCORE 'Atomic';
terminal KW_ATTRIBUTE: SKW_UNDERSCORE SKW_UNDERSCORE 'attribute' SKW_UNDERSCORE SKW_UNDERSCORE;
terminal KW_AUTO : 'auto';
terminal KW_ALIGNAS : SKW_UNDERSCORE 'Alignas';
terminal KW_ALIGNOF : SKW_UNDERSCORE 'Alignof';
terminal KW_ASM1: 'asm';
terminal KW_ASM2: SKW_UNDERSCORE SKW_UNDERSCORE KW_ASM1;
terminal KW_ASM3: KW_ASM2 SKW_UNDERSCORE SKW_UNDERSCORE;
terminal KW_BOOL : SKW_UNDERSCORE 'Bool';
terminal KW_BREAK : 'break';
terminal KW_BUILTIN_VA_LIST: SKW_UNDERSCORE SKW_UNDERSCORE 'builtin_va_list';
terminal KW_CASE : 'case';
terminal KW_CHAR : 'char';
terminal KW_COMPLEX : SKW_UNDERSCORE 'Complex';
terminal KW_CONST : 'const';
terminal KW_CONTINUE : 'continue';
terminal KW_DEFAULT : 'default';
terminal KW_DO : 'do';
terminal KW_DOUBLE : 'double';
terminal KW_ELSE : 'else';
terminal KW_EXTENSION: SKW_UNDERSCORE SKW_UNDERSCORE 'extension' SKW_UNDERSCORE SKW_UNDERSCORE;
terminal KW_ENUM : 'enum';
terminal KW_EXTERN : 'extern';
terminal KW_FLOAT : 'float';
terminal KW_FOR : 'for';
terminal KW_GENERIC : SKW_UNDERSCORE 'Generic';
terminal KW_GOTO : 'goto';
terminal KW_IF : 'if';
terminal KW_IMAGINARY : SKW_UNDERSCORE 'Imaginary';
terminal KW_INLINE1 : 'inline';
terminal KW_INLINE2 : SKW_UNDERSCORE SKW_UNDERSCORE KW_INLINE1;
terminal KW_INT : 'int';
terminal KW_LONG : 'long';
terminal KW_M128: SKW_UNDERSCORE SKW_UNDERSCORE 'm128';
terminal KW_M128D: KW_M128 'd';
terminal KW_M128I: KW_M128 'i';
terminal KW_NORETURN : SKW_UNDERSCORE 'Noreturn';
terminal KW_PRAGMA: 'pragma';
terminal KW_REGISTER : 'register';
terminal KW_RESTRICT : 'restrict';
terminal KW_RESTRICT2: SKW_UNDERSCORE SKW_UNDERSCORE KW_RESTRICT;
terminal KW_RESTRICT3: KW_RESTRICT2 SKW_UNDERSCORE SKW_UNDERSCORE;
terminal KW_RETURN : 'return';
terminal KW_SHORT : 'short';
terminal KW_SIGNED1 : 'signed';
terminal KW_SIGNED2 : SKW_UNDERSCORE SKW_UNDERSCORE KW_SIGNED1;
terminal KW_SIGNED3 : KW_SIGNED2 SKW_UNDERSCORE SKW_UNDERSCORE;

terminal KW_SIZEOF : 'sizeof';
terminal KW_STATIC : 'static';
terminal KW_STATICASSERT : SKW_UNDERSCORE 'Static_assert';
terminal KW_STRUCT : 'struct';
terminal KW_SWITCH : 'switch';
terminal KW_THREADLOCAL : SKW_UNDERSCORE 'Thread_local';
terminal KW_TYPEDEF : 'typedef';
terminal KW_UNION : 'union';
terminal KW_UNSIGNED : 'unsigned';
terminal KW_VOID : 'void';
terminal KW_VOLATILE : 'volatile';
terminal KW_VOLATILE2: SKW_UNDERSCORE SKW_UNDERSCORE KW_VOLATILE SKW_UNDERSCORE SKW_UNDERSCORE ;
terminal KW_WHILE : 'while';



/*** assigning operators ***/
terminal STARASSIGN: SKW_STAR SKW_ASSIGN;
terminal DIVASSIGN: SKW_DIV SKW_ASSIGN;
terminal MODASSIGN: SKW_MOD SKW_ASSIGN;
terminal PLUSASSIGN: SKW_PLUS SKW_ASSIGN;
terminal MINUSASSIGN: SKW_MINUS SKW_ASSIGN;
terminal LEFTSHIFTASSIGN: SKW_LEFTSHIFT SKW_ASSIGN;
terminal RIGHTSHIFTASSIGN:SKW_RIGHTSHIFT SKW_ASSIGN;
terminal ANDASSIGN: SKW_AND SKW_ASSIGN;
terminal XORASSIGN: SKW_CARET SKW_ASSIGN;
terminal ORASSIGN: SKW_OR SKW_ASSIGN;

terminal ARROW: SKW_MINUS SKW_GREATER;

/*** Whitespace specifics ***/
terminal LINEDIRECTIVE: '#' (!NEWLINE | SKW_BACKSLASH NEWLINE)*;
terminal WHITESPACE: (' ' | '\t')+;
