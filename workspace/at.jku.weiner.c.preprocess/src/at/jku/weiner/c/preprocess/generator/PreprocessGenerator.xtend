/*
 * generated by Xtext 2.9.0-SNAPSHOT
 */
package at.jku.weiner.c.preprocess.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtend.lib.annotations.Accessors
import at.jku.weiner.c.common.common.TranslationUnit
import at.jku.weiner.c.common.common.Model
import at.jku.weiner.c.preprocess.preprocess.PreprocessorDirectives
import at.jku.weiner.c.preprocess.preprocess.NewLineLine
import at.jku.weiner.c.preprocess.preprocess.Code
import at.jku.weiner.c.preprocess.preprocess.IncludeDirective
import at.jku.weiner.c.preprocess.preprocess.DefineDirective
import at.jku.weiner.c.preprocess.preprocess.UnDefineDirective
import at.jku.weiner.c.preprocess.preprocess.ErrorDirective
import at.jku.weiner.c.preprocess.preprocess.PragmaDirective
import at.jku.weiner.c.preprocess.utils.macros.DefinitionTable
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.emf.common.util.URI
import at.jku.weiner.c.preprocess.preprocess.GroupOpt
import at.jku.weiner.c.preprocess.utils.IncludeUtils
import at.jku.weiner.c.preprocess.preprocess.DefineObjectMacro
import at.jku.weiner.c.preprocess.preprocess.DefineFunctionLikeMacro
import at.jku.weiner.c.preprocess.preprocess.ConditionalDirective
import at.jku.weiner.c.preprocess.preprocess.IfDefConditional
import at.jku.weiner.c.preprocess.preprocess.IfNotDefConditional
import at.jku.weiner.c.preprocess.preprocess.IfConditional
import at.jku.weiner.c.preprocess.utils.expressions.ExpressionEvaluation
import at.jku.weiner.c.preprocess.preprocess.ElseConditional
import org.eclipse.emf.common.util.EList
import at.jku.weiner.c.preprocess.preprocess.ElIfConditional
import at.jku.weiner.c.preprocess.utils.IncludeDirs
import com.google.inject.Inject
import org.eclipse.xtext.validation.IResourceValidator
import java.util.List
import org.eclipse.xtext.validation.Issue
import org.eclipse.xtext.validation.CheckMode
import org.eclipse.xtext.util.CancelIndicator
import com.google.inject.Injector
import at.jku.weiner.c.common.CommonStandaloneSetup
import at.jku.weiner.c.preprocess.utils.macros.MacroParentheseNotClosedYetException
import at.jku.weiner.c.preprocess.preprocess.SourceCodeLine
import java.util.ArrayList
import at.jku.weiner.c.preprocess.preprocess.Preprocess
import at.jku.weiner.c.common.common.CommonFactory
import at.jku.weiner.c.preprocess.preprocess.IfAbstractConditional

import at.jku.weiner.c.preprocess.utils.macros.PredefinedMacros
import at.jku.weiner.c.preprocess.utils.macros.AdditionalPreprocessingDirectives
import java.util.Stack
import at.jku.weiner.c.common.log.MyLog
import org.eclipse.xtext.parser.antlr.ITokenDefProvider
import at.jku.weiner.c.preprocess.parser.antlr.internal.InternalPreprocessLexer
import at.jku.weiner.c.preprocess.utils.LexerUtils
import at.jku.weiner.c.preprocess.utils.Trimmer
import at.jku.weiner.c.common.common.Expression
import at.jku.weiner.c.preprocess.preprocess.LineDirective

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class PreprocessGenerator implements IGenerator {

	@Accessors String fileName = 'hello_world.cdt.i';
	@Accessors TranslationUnit unit = null;
	@Accessors boolean legacyMode = true;
	@Accessors boolean insertPredefinedMacros = false;
	@Accessors boolean validateUnit = true;
	// @Accessors boolean addToModel = false;
	@Accessors Injector commonInjector;
	@Accessors boolean stdInclude = true;
	@Accessors String additionalPreprocessingDirectives = null;
	@Accessors boolean trimPreprocessModel = false;
	
	@Inject
	IResourceValidator validator;
	@Inject
	ITokenDefProvider tokenDefProvider;
	@Inject
	InternalPreprocessLexer lexer;
	
	ResourceSet rs;
	URI uri;
	Stack<URI> currUri;
	List<String> path = new ArrayList<String>();
	boolean standAlone = false;
	DefinitionTable definitionTable;
	Stack<String> currFileNames;
	Stack<String> currLineNumber;
	
	override void doGenerate(Resource input, IFileSystemAccess fsa) {
		setUp();
		rs = input.resourceSet;
		uri = input.URI;
		currUri = new Stack<URI>;
		currFileNames = new Stack<String>;
		currLineNumber = new Stack<String>;
		currUri.push(uri);
		if (stdInclude) {
			IncludeDirs.setUp();
		}
		path.clear();
		definitionTable.reset();
		if (insertPredefinedMacros) {
			insertPredefinedMacros();
		}
		val String additional = addAdditionalPreprocessingDirectives(rs);
		
		val Preprocess preprocess = getPreprocessFor(input, false);
		val String output = outputFor(preprocess);
		val String result = additional + removeInvalid(output);
		MyLog.debug(PreprocessGenerator.getClass, "generating output file='" + fileName + "'");
		fsa.generateFile(fileName, result);
		trimPreprocess(preprocess);
	}
	
	def void setUp() {
		if (commonInjector == null) {
			standAlone = true;
			// only do when we are executing tests,
			// but not when in Eclipse environment
			val CommonStandaloneSetup setup = new CommonStandaloneSetup();
			val Injector injector = setup.createInjectorAndDoEMFRegistration();
			commonInjector = injector;
		}
		val LexerUtils utils = new LexerUtils(this.lexer, this.tokenDefProvider);
		definitionTable = new DefinitionTable(utils);
	}
	
	def void insertPredefinedMacros() {
		val Preprocess predefined = PredefinedMacros.loadPreDefinedMacros(standAlone, this.stdInclude);
		path.add("/predefined/");
		currFileNames.push("/predefined/");
		currLineNumber.push("0");
		registerFileName();
		registerLineNumber();
		val String output = outputFor(predefined);
		output.trim();
		currFileNames.pop();
		currLineNumber.pop();
	}
	
	def String addAdditionalPreprocessingDirectives(ResourceSet resourceSet) {
		if (this.additionalPreprocessingDirectives == null || additionalPreprocessingDirectives.isEmpty()) {
			return "";
		}
		val Preprocess additional = AdditionalPreprocessingDirectives.getAdditionalDirectivesFor(
			additionalPreprocessingDirectives
		);
		currLineNumber.push("0");
		currFileNames.push("/additionalPreprocessingDirectives/");
		registerFileName();
		registerLineNumber();
		path.add("/additionalPreprocessingDirectives/");
		val String result = outputFor(additional);
		currFileNames.pop();
		currLineNumber.pop();
		return result.trim();
	}
	
	def Preprocess getPreprocessFor(Resource input, boolean forceLoading) {
		var Preprocess preprocess = null;
		validatePreprocess(input);
		//val String fileName = getFileName(input);
		val tempFileName = getFileName(input);
		currLineNumber.push("0");
		currFileNames.push(tempFileName);
		registerFileName();
		registerLineNumber();
		if (this.unit == null) {
			preprocess = input.allContents.filter(typeof(Preprocess)).head;
			MyLog.trace(PreprocessGenerator.getClass, "unit-null: preprocess='" 
				+ preprocess + "'" + currFileNames.peek() + "'"
			);
		}
		else {
			preprocess = unit.preprocess as Preprocess;
			if (preprocess == null || forceLoading) {
				preprocess = loadExistingPreprocess(currFileNames.peek());
				MyLog.debug(PreprocessGenerator.getClass, "force-loading: preprocess='" 
					+ preprocess + "'" + currFileNames.peek() + "'"
				);
				if (preprocess == null) {
					preprocess = input.allContents.filter(typeof(Preprocess)).head;
					MyLog.debug(PreprocessGenerator.getClass, "filtering: preprocess='" 
						+ preprocess + "'" + currFileNames.peek() + "'"
					);
				}
			}
		}
		
		if (preprocess == null) {
			val RuntimeException ex = new RuntimeException("preprocess is null!");
			MyLog.error(PreprocessGenerator.getClass, ex);
		}
		
		//val TranslationUnit unit = model.getUnits().head;
		// unit.setPath(fileName);
		path.add("/" + currFileNames.peek() + "/");
		return preprocess;
	}
	
	def String getFileName(Resource input) {
		val URI myuri = input.URI;
		var String fileName = myuri.toFileString;
		this.currUri.push(myuri);
		if (fileName == null) {
			fileName = myuri.toPlatformString(false);
		}
		val String path = fileName.replaceAll("^///", "/");
		return path;
	}
	
	def Preprocess loadExistingPreprocess(String filePath) {
		val Model model = unit.eContainer as Model;
		if (model == null) {
			return null;
		}
		val EList<TranslationUnit> units = model.units;
		for (var int i = 0; i < units.size; i++) {
			val TranslationUnit myUnit = units.get(i);
			if (filePath.equals(myUnit.path)) {
				return myUnit.preprocess as Preprocess;
			}
		}
		return null;
	}
	
	def void validatePreprocess(Resource resource) {
		if (!validateUnit) {
			return;
		}
		val List<Issue> list = validator.validate(resource, CheckMode.ALL, 
			CancelIndicator.NullImpl
		);
		if (!(list.isEmpty())) {
			val RuntimeException ex = new RuntimeException("error during validation of unit='" 
				+ list.toString() + "'"
			);
			MyLog.error(PreprocessGenerator.getClass, ex);
		}
	}
	
	def String outputFor(Preprocess preprocess) {
		val String result= outputFor(preprocess.group);
		return result;
	}
	
	def String outputFor(GroupOpt group) {
		MyLog.debug(PreprocessGenerator.getClass, "outputFor path='" + path + "'");
		
		val StringBuffer result = new StringBuffer("");
		registerLineNumber();
		for (var int i = 0; i < group.lines.size; i++) {
			var SourceCodeLine obj = group.lines.get(i);
			if (obj instanceof PreprocessorDirectives) {
				result.append(outputFor(obj as PreprocessorDirectives));
			}
			else if (obj instanceof NewLineLine) {
				result.append(outputFor(obj as NewLineLine));
			}
			else if (obj instanceof Code) {
				var boolean fullResolved = false;
				var String codeResult = "";
				val List<Code> codeList = new ArrayList<Code>();
				do {
					try {
						val SourceCodeLine line = obj as SourceCodeLine;
						if (line instanceof Code) {
							val Code code = obj as Code;
							codeList.add(code);
							codeResult = outputFor(codeList);
							fullResolved = true;
						}
						else if (line instanceof NewLineLine) {
							i++;
							obj = group.lines.get(i);
						}
						else {
							val RuntimeException ex = new IllegalArgumentException("Can not nest a preprocessor directive while looking of a closing parentheses!");
							MyLog.error(PreprocessGenerator.getClass, ex);
						}
					} catch (MacroParentheseNotClosedYetException ex) {
						MyLog.debug(PreprocessGenerator.getClass, "not fully resolved at='" + i + "'");
						i++;
						obj = group.lines.get(i);
						//fullResolved = true;
					}
				} while (!fullResolved);
				result.append(codeResult);
				result.append(getNewLine());
			}
			incrementCurrLineNumber();
		}
		path.remove(path.length() - 1);
		MyLog.debug(PreprocessGenerator.getClass, "back in path='" + path + "'");
		return result.toString();
	}

	def String outputFor(PreprocessorDirectives obj) '''
		«IF obj.directive instanceof IncludeDirective»
			«outputFor(obj.directive as IncludeDirective)»
		«ELSEIF obj.directive instanceof DefineDirective»
			«outputFor(obj.directive as DefineDirective)»
		«ELSEIF obj.directive instanceof UnDefineDirective»
			«outputFor(obj.directive as UnDefineDirective)»
		«ELSEIF obj.directive instanceof ConditionalDirective»
			«outputFor(obj.directive as ConditionalDirective)»
		«ELSEIF obj.directive instanceof LineDirective»
			«outputFor(obj.directive as LineDirective)»
		«ELSEIF obj.directive instanceof ErrorDirective»
			«outputFor(obj.directive as ErrorDirective)»
		«ELSEIF obj.directive instanceof PragmaDirective»
			«outputFor(obj.directive as PragmaDirective)»
		«ENDIF»
	'''
	
	def String outputFor(IncludeDirective obj) {
		if (legacyMode) {
			return outputForLegacyMode(obj);
		}
		return "";
	}
	
	def String outputForLegacyMode(IncludeDirective obj) {
		val String inc = obj.string;
		val IncludeUtils includeUtils = new IncludeUtils(rs, this.currUri.peek(), inc, definitionTable, obj.next);
		val Resource res = includeUtils.getResource();
		//val TranslationUnit unit = this.getUnitFor(res);
		//val String output = outputFor(unit);
		
		val Preprocess preprocess = this.getPreprocessFor(res, true);
		if (this.unit != null && preprocess.eContainer == null) {
			val Model model = this.unit.eContainer as Model;
			val CommonFactory factory = CommonFactory.eINSTANCE;
			val TranslationUnit unit2 = factory.createTranslationUnit();
			val String path = getFileName(res);
			
			unit2.path = path;
			model.units.add(unit2);
			unit2.preprocess = preprocess;
			obj.unit = unit2;
		}
		val String output = outputFor(preprocess);
		
		
		currUri.pop();
		currFileNames.pop();
		currLineNumber.pop();
		//path.remove(path.length() -1);
		return output;
	}
	
	def String outputFor(DefineDirective obj) {
		if (obj instanceof DefineObjectMacro) {
			definitionTable.add(obj.ident, obj.string);
		}
		else if (obj instanceof DefineFunctionLikeMacro) {
			definitionTable.addFunctionMacro(obj.ident, obj.list, obj.string);
		}
		return "";
	}
	
	def String outputFor(UnDefineDirective obj) {
		definitionTable.remove(obj.ident);
		return "";
	}
	
	def String outputFor(ConditionalDirective obj) {
		val StringBuffer result = new StringBuffer(""); 
		obj.branchTaken = null;
		
		if (obj.conditional instanceof IfConditional) {
			result.append(outputFor(obj, obj.conditional as IfConditional));
		}
		else if (obj.conditional instanceof IfDefConditional) {
			result.append(outputFor(obj, obj.conditional as IfDefConditional)); 
		}
		else if (obj.conditional instanceof IfNotDefConditional) {
			result.append(outputFor(obj, obj.conditional as IfNotDefConditional)); 
		}
		result.append(outputFor(obj, obj.getElifs()));
		result.append(outputFor(obj, obj.getElse()));
		return result.toString();
	}
	
	def String outputFor(ConditionalDirective condDirective, IfDefConditional obj) {
		if (definitionTable.isDefined(obj.ident)) {
			condDirective.branchTaken = obj;
			obj.branchTaken = true;
			
			path.add("ifdef " + obj.id + "/");
			return outputFor(obj.group).trim();
		}
		return "";
	}
	
	def String outputFor(ConditionalDirective condDirective, IfNotDefConditional obj) {
		if (!(definitionTable.isDefined(obj.ident))) {
			condDirective.branchTaken = obj;
			obj.branchTaken = true;
			
			path.add("ifnotdef " + obj.id + "/");
			return outputFor(obj.group).trim();
		}
		return "";
	}
	
	def String outputFor(ConditionalDirective condDirective, IfConditional obj) {
		val Expression expr = obj.expression;
		val String string = ExpressionEvaluation.evaluateFor(expr);
		val boolean result = ExpressionEvaluation.evaluateFor(expr, commonInjector, definitionTable);
		MyLog.trace(PreprocessGenerator.getClass, "resultOfExpr='" + string + "'='" + result + "'");
		if (result) {
			path.add("if " + string + "/");
			condDirective.branchTaken = obj;
			obj.branchTaken = true;
			return outputFor(obj.group).trim();
		}
		return "";
	}
	
	def String outputFor(ConditionalDirective condDirective, EList<ElIfConditional> obj) {
		if (obj == null) {
 			return "";
 		}
 		val IfAbstractConditional condition = condDirective.branchTaken;
 		if (condition != null) {
 			return "";
 		}
 		val StringBuffer result = new StringBuffer(""); 
 		for (ElIfConditional cond : obj) {
 			result.append(outputFor(condDirective, cond));
 		}
 		return result.toString();
 	}
 	
 	def String outputFor(ConditionalDirective condDirective, ElIfConditional obj) {
 		val IfAbstractConditional condition = condDirective.branchTaken;
 		if (condition != null) {
 			return "";
 		}
 		val Expression expr = obj.expression;
 		if (ExpressionEvaluation.evaluateFor(expr, commonInjector, definitionTable)) {
 			val String string = ExpressionEvaluation.evaluateFor(expr);
			path.add("elif" + string + "/");
			condDirective.branchTaken = obj;
			obj.branchTaken = true;
			return outputFor(obj.group).trim();
		}
 		return "";
 	}
	
	def String outputFor(ConditionalDirective condDirective, ElseConditional obj) {
		val IfAbstractConditional condition = condDirective.branchTaken;
 		if (condition != null) {
 			return "";
 		}
		else if (obj== null) {
			return "";
		}
		condDirective.branchTaken = obj;
		obj.branchTaken = true;
		path.add("else/");
		return outputFor(obj.group).trim();
	}
	
	def String outputFor(LineDirective obj) {
		val String lineUnresolved = obj.line;
		val String line = resolve(lineUnresolved);
		this.currLineNumber.pop();
		this.currLineNumber.push(line);
		registerLineNumber();
		val String pathUnresolved = obj.path;
		if (pathUnresolved != null) {
			val String pathPure = resolve(pathUnresolved);
			this.currFileNames.pop();
			this.currFileNames.push(pathPure);
			registerFileName();
		}
		return "";
	}

	
	def String outputFor(ErrorDirective obj) '''
	'''
	
	def String outputFor(PragmaDirective obj) '''
	'''
	
	def String outputFor(NewLineLine obj) {
		return getNewLine();
	}
	
	def String getNewLine() '''

	'''
	
	def String outputFor(List<Code> obj) {
		val StringBuffer text = new StringBuffer("");
		for (Code code : obj) {
			text.append(code.code);
		}
		val String result = resolve(text.toString());
		return result;
	}
	
	def String resolve(String code) {
		definitionTable.fullResolve(code);
	}

	def DefinitionTable getDefinitionTable() {
		return this.definitionTable;
	}
	
	def String removeInvalid(String my) {
//		val char c000c = '\u000c';
//		val String result = my.replace("" + c000c, "");
		// return result;
		return my;
	}
	
	def trimPreprocess(Preprocess preprocess) {
		if (!this.trimPreprocessModel) {
			return;
		}
		Trimmer.trimPreprocess(preprocess);
	}
	
	def incrementCurrLineNumber() {
		val String tempLineNumAsStr = this.currLineNumber.pop();
		val Integer tempLineNum = Integer.valueOf(tempLineNumAsStr);
		val int i = tempLineNum.intValue + 1;
		this.currLineNumber.push("" + i);
		registerLineNumber();
	}
	
	def registerLineNumber() {
		this.definitionTable.remove(PredefinedMacros.MACRO_LINE);
		this.definitionTable.add(PredefinedMacros.MACRO_LINE, this.currLineNumber.peek());
	}
	
	def registerFileName() {
		this.definitionTable.remove(PredefinedMacros.MACRO_FILE);
		val String temp = this.currFileNames.peek();
		if (temp.startsWith("\"")) {
			this.definitionTable.add(PredefinedMacros.MACRO_FILE, this.currFileNames.peek());
		}
		else {
			this.definitionTable.add(PredefinedMacros.MACRO_FILE, 
			'"' + this.currFileNames.peek() + '"');
		}
	}
}
