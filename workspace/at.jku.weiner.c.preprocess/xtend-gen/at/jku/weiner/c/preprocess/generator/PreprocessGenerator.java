/**
 * generated by Xtext 2.9.0-SNAPSHOT
 */
package at.jku.weiner.c.preprocess.generator;

import at.jku.weiner.c.preprocess.parser.antlr.internal.InternalPreprocessLexer;
import at.jku.weiner.c.preprocess.preprocess.Code;
import at.jku.weiner.c.preprocess.preprocess.ConditionalDirective;
import at.jku.weiner.c.preprocess.preprocess.DefineDirective;
import at.jku.weiner.c.preprocess.preprocess.DefineFunctionLikeMacro;
import at.jku.weiner.c.preprocess.preprocess.DefineObjectMacro;
import at.jku.weiner.c.preprocess.preprocess.ElIfConditional;
import at.jku.weiner.c.preprocess.preprocess.ElseConditional;
import at.jku.weiner.c.preprocess.preprocess.ErrorDirective;
import at.jku.weiner.c.preprocess.preprocess.GroupOpt;
import at.jku.weiner.c.preprocess.preprocess.IdentifierList;
import at.jku.weiner.c.preprocess.preprocess.IfAbstractConditional;
import at.jku.weiner.c.preprocess.preprocess.IfConditional;
import at.jku.weiner.c.preprocess.preprocess.IfDefConditional;
import at.jku.weiner.c.preprocess.preprocess.IfNotDefConditional;
import at.jku.weiner.c.preprocess.preprocess.IncludeDirective;
import at.jku.weiner.c.preprocess.preprocess.LineDirective;
import at.jku.weiner.c.preprocess.preprocess.NewLineLine;
import at.jku.weiner.c.preprocess.preprocess.PragmaDirective;
import at.jku.weiner.c.preprocess.preprocess.Preprocess;
import at.jku.weiner.c.preprocess.preprocess.PreprocessorDirectives;
import at.jku.weiner.c.preprocess.preprocess.UnDefineDirective;
import at.jku.weiner.c.preprocess.utils.Trimmer;
import at.jku.weiner.c.preprocess.utils.macros.AdditionalPreprocessingDirectives;
import at.jku.weiner.c.preprocess.utils.macros.DefinitionTable;
import at.jku.weiner.c.preprocess.utils.macros.PredefinedMacros;
import com.google.common.base.Objects;
import com.google.inject.Inject;
import com.google.inject.Injector;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.xtend.lib.annotations.Accessors;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.parser.antlr.ITokenDefProvider;
import org.eclipse.xtext.validation.IResourceValidator;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Pure;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class PreprocessGenerator implements IGenerator {
  @Accessors
  private String fileName = "hello_world.cdt.i";
  
  @Accessors
  private /* TranslationUnit */Object unit = null;
  
  @Accessors
  private boolean legacyMode = true;
  
  @Accessors
  private boolean insertPredefinedMacros = false;
  
  @Accessors
  private boolean validateUnit = true;
  
  @Accessors
  private Injector commonInjector;
  
  @Accessors
  private boolean stdInclude = true;
  
  @Accessors
  private String additionalPreprocessingDirectives = null;
  
  @Accessors
  private boolean trimPreprocessModel = false;
  
  @Inject
  private IResourceValidator validator;
  
  @Inject
  private ITokenDefProvider tokenDefProvider;
  
  @Inject
  private InternalPreprocessLexer lexer;
  
  private ResourceSet rs;
  
  private URI uri;
  
  private Stack<URI> currUri;
  
  private List<String> path = new ArrayList<String>();
  
  private boolean standAlone = false;
  
  private DefinitionTable definitionTable;
  
  private Stack<String> currFileNames;
  
  private Stack<String> currLineNumber;
  
  @Override
  public void doGenerate(final Resource input, final IFileSystemAccess fsa) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field MyLog is undefined"
      + "\ndebug cannot be resolved");
  }
  
  public void setUp() {
    throw new Error("Unresolved compilation problems:"
      + "\nCommonStandaloneSetup cannot be resolved to a type."
      + "\nCommonStandaloneSetup cannot be resolved."
      + "\ncreateInjectorAndDoEMFRegistration cannot be resolved");
  }
  
  public void insertPredefinedMacros() {
    final Preprocess predefined = PredefinedMacros.loadPreDefinedMacros(this.standAlone, this.stdInclude);
    this.path.add("/predefined/");
    this.currFileNames.push("/predefined/");
    this.currLineNumber.push("0");
    this.registerFileName();
    this.registerLineNumber();
    final String output = this.outputFor(predefined);
    output.trim();
    this.currFileNames.pop();
    this.currLineNumber.pop();
  }
  
  public String addAdditionalPreprocessingDirectives(final ResourceSet resourceSet) {
    try {
      boolean _or = false;
      boolean _equals = Objects.equal(this.additionalPreprocessingDirectives, null);
      if (_equals) {
        _or = true;
      } else {
        boolean _isEmpty = this.additionalPreprocessingDirectives.isEmpty();
        _or = _isEmpty;
      }
      if (_or) {
        return "";
      }
      final Preprocess additional = AdditionalPreprocessingDirectives.getAdditionalDirectivesFor(
        this.additionalPreprocessingDirectives);
      this.currLineNumber.push("0");
      this.currFileNames.push("/additionalPreprocessingDirectives/");
      this.registerFileName();
      this.registerLineNumber();
      this.path.add("/additionalPreprocessingDirectives/");
      final String result = this.outputFor(additional);
      this.currFileNames.pop();
      this.currLineNumber.pop();
      return result.trim();
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public Preprocess getPreprocessFor(final Resource input, final boolean forceLoading) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field MyLog is undefined"
      + "\nThe method or field MyLog is undefined"
      + "\nThe method or field MyLog is undefined"
      + "\nThe method or field MyLog is undefined"
      + "\n== cannot be resolved"
      + "\ntrace cannot be resolved"
      + "\npreprocess cannot be resolved"
      + "\ndebug cannot be resolved"
      + "\ndebug cannot be resolved"
      + "\nerror cannot be resolved");
  }
  
  public String getFileName(final Resource input) {
    final URI myuri = input.getURI();
    String fileName = myuri.toFileString();
    this.currUri.push(myuri);
    boolean _equals = Objects.equal(fileName, null);
    if (_equals) {
      String _platformString = myuri.toPlatformString(false);
      fileName = _platformString;
    }
    final String path = fileName.replaceAll("^///", "/");
    return path;
  }
  
  public Preprocess loadExistingPreprocess(final String filePath) {
    throw new Error("Unresolved compilation problems:"
      + "\nModel cannot be resolved to a type."
      + "\nModel cannot be resolved to a type."
      + "\nTranslationUnit cannot be resolved to a type."
      + "\nTranslationUnit cannot be resolved to a type."
      + "\neContainer cannot be resolved"
      + "\n== cannot be resolved"
      + "\nunits cannot be resolved"
      + "\npath cannot be resolved"
      + "\npreprocess cannot be resolved");
  }
  
  public void validatePreprocess(final Resource resource) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field MyLog is undefined"
      + "\nerror cannot be resolved");
  }
  
  public String outputFor(final Preprocess preprocess) {
    GroupOpt _group = preprocess.getGroup();
    final String result = this.outputFor(_group);
    return result;
  }
  
  public String outputFor(final GroupOpt group) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field MyLog is undefined"
      + "\nThe method or field MyLog is undefined"
      + "\nThe method or field MyLog is undefined"
      + "\nThe method or field MyLog is undefined"
      + "\ndebug cannot be resolved"
      + "\nerror cannot be resolved"
      + "\ndebug cannot be resolved"
      + "\ndebug cannot be resolved");
  }
  
  public String outputFor(final PreprocessorDirectives obj) {
    StringConcatenation _builder = new StringConcatenation();
    {
      EObject _directive = obj.getDirective();
      if ((_directive instanceof IncludeDirective)) {
        EObject _directive_1 = obj.getDirective();
        String _outputFor = this.outputFor(((IncludeDirective) _directive_1));
        _builder.append(_outputFor, "");
        _builder.newLineIfNotEmpty();
      } else {
        EObject _directive_2 = obj.getDirective();
        if ((_directive_2 instanceof DefineDirective)) {
          EObject _directive_3 = obj.getDirective();
          String _outputFor_1 = this.outputFor(((DefineDirective) _directive_3));
          _builder.append(_outputFor_1, "");
          _builder.newLineIfNotEmpty();
        } else {
          EObject _directive_4 = obj.getDirective();
          if ((_directive_4 instanceof UnDefineDirective)) {
            EObject _directive_5 = obj.getDirective();
            String _outputFor_2 = this.outputFor(((UnDefineDirective) _directive_5));
            _builder.append(_outputFor_2, "");
            _builder.newLineIfNotEmpty();
          } else {
            EObject _directive_6 = obj.getDirective();
            if ((_directive_6 instanceof ConditionalDirective)) {
              EObject _directive_7 = obj.getDirective();
              String _outputFor_3 = this.outputFor(((ConditionalDirective) _directive_7));
              _builder.append(_outputFor_3, "");
              _builder.newLineIfNotEmpty();
            } else {
              EObject _directive_8 = obj.getDirective();
              if ((_directive_8 instanceof LineDirective)) {
                EObject _directive_9 = obj.getDirective();
                String _outputFor_4 = this.outputFor(((LineDirective) _directive_9));
                _builder.append(_outputFor_4, "");
                _builder.newLineIfNotEmpty();
              } else {
                EObject _directive_10 = obj.getDirective();
                if ((_directive_10 instanceof ErrorDirective)) {
                  EObject _directive_11 = obj.getDirective();
                  String _outputFor_5 = this.outputFor(((ErrorDirective) _directive_11));
                  _builder.append(_outputFor_5, "");
                  _builder.newLineIfNotEmpty();
                } else {
                  EObject _directive_12 = obj.getDirective();
                  if ((_directive_12 instanceof PragmaDirective)) {
                    EObject _directive_13 = obj.getDirective();
                    String _outputFor_6 = this.outputFor(((PragmaDirective) _directive_13));
                    _builder.append(_outputFor_6, "");
                    _builder.newLineIfNotEmpty();
                  }
                }
              }
            }
          }
        }
      }
    }
    return _builder.toString();
  }
  
  public String outputFor(final IncludeDirective obj) {
    if (this.legacyMode) {
      return this.outputForLegacyMode(obj);
    }
    return "";
  }
  
  public String outputForLegacyMode(final IncludeDirective obj) {
    throw new Error("Unresolved compilation problems:"
      + "\nModel cannot be resolved to a type."
      + "\nModel cannot be resolved to a type."
      + "\nCommonFactory cannot be resolved to a type."
      + "\nTranslationUnit cannot be resolved to a type."
      + "\nThe method or field eContainer is undefined for the type Preprocess"
      + "\nThe method or field CommonFactory is undefined"
      + "\nInvalid number of arguments. The method setUnit(TranslationUnit) is not applicable for the arguments (IncludeDirective,TranslationUnit)"
      + "\n!= cannot be resolved"
      + "\n&& cannot be resolved"
      + "\n== cannot be resolved"
      + "\neContainer cannot be resolved"
      + "\neINSTANCE cannot be resolved"
      + "\ncreateTranslationUnit cannot be resolved"
      + "\npath cannot be resolved"
      + "\nunits cannot be resolved"
      + "\nadd cannot be resolved"
      + "\npreprocess cannot be resolved");
  }
  
  public String outputFor(final DefineDirective obj) {
    if ((obj instanceof DefineObjectMacro)) {
      String _ident = ((DefineObjectMacro)obj).getIdent();
      String _string = ((DefineObjectMacro)obj).getString();
      this.definitionTable.add(_ident, _string);
    } else {
      if ((obj instanceof DefineFunctionLikeMacro)) {
        String _ident_1 = ((DefineFunctionLikeMacro)obj).getIdent();
        IdentifierList _list = ((DefineFunctionLikeMacro)obj).getList();
        String _string_1 = ((DefineFunctionLikeMacro)obj).getString();
        this.definitionTable.addFunctionMacro(_ident_1, _list, _string_1);
      }
    }
    return "";
  }
  
  public String outputFor(final UnDefineDirective obj) {
    String _ident = obj.getIdent();
    this.definitionTable.remove(_ident);
    return "";
  }
  
  public String outputFor(final ConditionalDirective obj) {
    final StringBuffer result = new StringBuffer("");
    obj.setBranchTaken(null);
    IfAbstractConditional _conditional = obj.getConditional();
    if ((_conditional instanceof IfConditional)) {
      IfAbstractConditional _conditional_1 = obj.getConditional();
      String _outputFor = this.outputFor(obj, ((IfConditional) _conditional_1));
      result.append(_outputFor);
    } else {
      IfAbstractConditional _conditional_2 = obj.getConditional();
      if ((_conditional_2 instanceof IfDefConditional)) {
        IfAbstractConditional _conditional_3 = obj.getConditional();
        String _outputFor_1 = this.outputFor(obj, ((IfDefConditional) _conditional_3));
        result.append(_outputFor_1);
      } else {
        IfAbstractConditional _conditional_4 = obj.getConditional();
        if ((_conditional_4 instanceof IfNotDefConditional)) {
          IfAbstractConditional _conditional_5 = obj.getConditional();
          String _outputFor_2 = this.outputFor(obj, ((IfNotDefConditional) _conditional_5));
          result.append(_outputFor_2);
        }
      }
    }
    EList<ElIfConditional> _elifs = obj.getElifs();
    String _outputFor_3 = this.outputFor(obj, _elifs);
    result.append(_outputFor_3);
    ElseConditional _else = obj.getElse();
    String _outputFor_4 = this.outputFor(obj, _else);
    result.append(_outputFor_4);
    return result.toString();
  }
  
  public String outputFor(final ConditionalDirective condDirective, final IfDefConditional obj) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field id is undefined for the type IfDefConditional");
  }
  
  public String outputFor(final ConditionalDirective condDirective, final IfNotDefConditional obj) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field id is undefined for the type IfNotDefConditional");
  }
  
  public String outputFor(final ConditionalDirective condDirective, final IfConditional obj) {
    throw new Error("Unresolved compilation problems:"
      + "\nExpression cannot be resolved to a type."
      + "\nThe method evaluateFor(Expression) is undefined for the type Class<ExpressionEvaluation>"
      + "\nThe method evaluateFor(Expression, Injector, DefinitionTable) is undefined for the type Class<ExpressionEvaluation>"
      + "\nThe method or field MyLog is undefined"
      + "\ntrace cannot be resolved");
  }
  
  public String outputFor(final ConditionalDirective condDirective, final EList<ElIfConditional> obj) {
    boolean _equals = Objects.equal(obj, null);
    if (_equals) {
      return "";
    }
    final IfAbstractConditional condition = condDirective.getBranchTaken();
    boolean _notEquals = (!Objects.equal(condition, null));
    if (_notEquals) {
      return "";
    }
    final StringBuffer result = new StringBuffer("");
    for (final ElIfConditional cond : obj) {
      String _outputFor = this.outputFor(condDirective, cond);
      result.append(_outputFor);
    }
    return result.toString();
  }
  
  public String outputFor(final ConditionalDirective condDirective, final ElIfConditional obj) {
    throw new Error("Unresolved compilation problems:"
      + "\nExpression cannot be resolved to a type."
      + "\nThe method evaluateFor(Expression, Injector, DefinitionTable) is undefined for the type Class<ExpressionEvaluation>"
      + "\nThe method evaluateFor(Expression) is undefined for the type Class<ExpressionEvaluation>");
  }
  
  public String outputFor(final ConditionalDirective condDirective, final ElseConditional obj) {
    final IfAbstractConditional condition = condDirective.getBranchTaken();
    boolean _notEquals = (!Objects.equal(condition, null));
    if (_notEquals) {
      return "";
    } else {
      boolean _equals = Objects.equal(obj, null);
      if (_equals) {
        return "";
      }
    }
    condDirective.setBranchTaken(obj);
    obj.setBranchTaken(true);
    this.path.add("else/");
    GroupOpt _group = obj.getGroup();
    String _outputFor = this.outputFor(_group);
    return _outputFor.trim();
  }
  
  public String outputFor(final LineDirective obj) {
    final String lineUnresolved = obj.getLine();
    final String line = this.resolve(lineUnresolved);
    this.currLineNumber.pop();
    Integer _valueOf = Integer.valueOf(line);
    int _minus = ((_valueOf).intValue() - 1);
    String _valueOf_1 = String.valueOf(_minus);
    this.currLineNumber.push(_valueOf_1);
    this.registerLineNumber();
    final String pathUnresolved = obj.getPath();
    boolean _notEquals = (!Objects.equal(pathUnresolved, null));
    if (_notEquals) {
      final String pathPure = this.resolve(pathUnresolved);
      this.currFileNames.pop();
      this.currFileNames.push(pathPure);
      this.registerFileName();
    }
    return "";
  }
  
  public String outputFor(final ErrorDirective obj) {
    StringConcatenation _builder = new StringConcatenation();
    return _builder.toString();
  }
  
  public String outputFor(final PragmaDirective obj) {
    StringConcatenation _builder = new StringConcatenation();
    return _builder.toString();
  }
  
  public String outputFor(final NewLineLine obj) {
    return this.getNewLine();
  }
  
  public String getNewLine() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.newLine();
    return _builder.toString();
  }
  
  public String outputFor(final List<Code> obj) {
    final StringBuffer text = new StringBuffer("");
    for (final Code code : obj) {
      String _code = code.getCode();
      text.append(_code);
    }
    String _string = text.toString();
    final String result = this.resolve(_string);
    return result;
  }
  
  public String resolve(final String code) {
    return this.definitionTable.fullResolve(code);
  }
  
  public DefinitionTable getDefinitionTable() {
    return this.definitionTable;
  }
  
  public String removeInvalid(final String my) {
    return my;
  }
  
  public void trimPreprocess(final Preprocess preprocess) {
    if ((!this.trimPreprocessModel)) {
      return;
    }
    Trimmer.trimPreprocess(preprocess);
  }
  
  public void incrementCurrLineNumber() {
    final String tempLineNumAsStr = this.currLineNumber.pop();
    final Integer tempLineNum = Integer.valueOf(tempLineNumAsStr);
    int _intValue = tempLineNum.intValue();
    final int i = (_intValue + 1);
    this.currLineNumber.push(("" + Integer.valueOf(i)));
    this.registerLineNumber();
  }
  
  public void registerLineNumber() {
    this.definitionTable.remove(PredefinedMacros.MACRO_LINE);
    String _peek = this.currLineNumber.peek();
    this.definitionTable.add(PredefinedMacros.MACRO_LINE, _peek);
  }
  
  public void registerFileName() {
    this.definitionTable.remove(PredefinedMacros.MACRO_FILE);
    final String temp = this.currFileNames.peek();
    boolean _startsWith = temp.startsWith("\"");
    if (_startsWith) {
      String _peek = this.currFileNames.peek();
      this.definitionTable.add(PredefinedMacros.MACRO_FILE, _peek);
    } else {
      String _peek_1 = this.currFileNames.peek();
      String _plus = ("\"" + _peek_1);
      String _plus_1 = (_plus + "\"");
      this.definitionTable.add(PredefinedMacros.MACRO_FILE, _plus_1);
    }
  }
  
  @Pure
  public String getFileName() {
    return this.fileName;
  }
  
  public void setFileName(final String fileName) {
    this.fileName = fileName;
  }
  
  @Pure
  public TranslationUnit getUnit() {
    return this.unit;
  }
  
  public void setUnit(final TranslationUnit unit) {
    this.unit = unit;
  }
  
  @Pure
  public boolean isLegacyMode() {
    return this.legacyMode;
  }
  
  public void setLegacyMode(final boolean legacyMode) {
    this.legacyMode = legacyMode;
  }
  
  @Pure
  public boolean isInsertPredefinedMacros() {
    return this.insertPredefinedMacros;
  }
  
  public void setInsertPredefinedMacros(final boolean insertPredefinedMacros) {
    this.insertPredefinedMacros = insertPredefinedMacros;
  }
  
  @Pure
  public boolean isValidateUnit() {
    return this.validateUnit;
  }
  
  public void setValidateUnit(final boolean validateUnit) {
    this.validateUnit = validateUnit;
  }
  
  @Pure
  public Injector getCommonInjector() {
    return this.commonInjector;
  }
  
  public void setCommonInjector(final Injector commonInjector) {
    this.commonInjector = commonInjector;
  }
  
  @Pure
  public boolean isStdInclude() {
    return this.stdInclude;
  }
  
  public void setStdInclude(final boolean stdInclude) {
    this.stdInclude = stdInclude;
  }
  
  @Pure
  public String getAdditionalPreprocessingDirectives() {
    return this.additionalPreprocessingDirectives;
  }
  
  public void setAdditionalPreprocessingDirectives(final String additionalPreprocessingDirectives) {
    this.additionalPreprocessingDirectives = additionalPreprocessingDirectives;
  }
  
  @Pure
  public boolean isTrimPreprocessModel() {
    return this.trimPreprocessModel;
  }
  
  public void setTrimPreprocessModel(final boolean trimPreprocessModel) {
    this.trimPreprocessModel = trimPreprocessModel;
  }
}
