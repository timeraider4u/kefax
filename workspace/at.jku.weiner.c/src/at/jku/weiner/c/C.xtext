/*
 [The "BSD licence"]
 Copyright (c) 2013 Sam Harwell
 Copyright (c) 2015 Harald Weiner
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
	notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
	notice, this list of conditions and the following disclaimer in the
	documentation and/or other materials provided with the distribution.
 3. The name of the author may not be used to endorse or promote products
	derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

grammar at.jku.weiner.c.C /*with org.eclipse.xtext.common.Terminals*/
hidden(LINEDIRECTIVE,LINE_COMMENT,BLOCK_COMMENT,NEWLINE,WHITESPACE,PRAGMADIRECTIVE)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate c "http://www.jku.at/weiner/c/C"

/*** parser ***/

Model: {Model} (unit+=TranslationUnit)?;

TranslationUnit 
	initRuleAction{
		at.jku.weiner.c.Scope.createNewScope("TranslationUnit");
	} 
	afterRuleAction{
		at.jku.weiner.c.Scope.removeScope();
	}
	:
	{TranslationUnit}
	
	(external+=ExternalDeclaration)+
;

ExternalDeclaration
	initRuleAction{
		at.jku.weiner.c.Log.log("ExternalDeclaration-enter");
	} 
	afterRuleAction{
		at.jku.weiner.c.Log.log("ExternalDeclaration-leave");
	}
	:
	{ExternalDeclaration}
	(
		(
			(=>
				functiondefHead=FunctionDefHead 
				LEFTBRACE
			)
			functionDefinition=FunctionDefinition
			RIGHTBRACE
		)
	|	declaration=Declaration
	|	semi=SEMI
	)
;

FunctionDefHead:
	{FunctionDefHead}
	(funDeclSpecifiers=DeclarationSpecifiers)? 
	funDeclarator=Declarator
	(funDeclaration+=Declaration)*
;

FunctionDefinition
	initRuleAction{
		at.jku.weiner.c.Scope.createNewScope("FunctionDefinition");
	} 
	afterRuleAction{
		at.jku.weiner.c.Scope.removeScope();
	}
	:
	{FunctionDefinition}
	body=BodyStatement
;


//
// ambiguity:
// 1.)declarationSpecifiers->declarationSpecifier->typeSpecifier->typedefName->IDENTIFIER
// 2.)initDeclaratorList->initDeclarator->declarator->directDeclarator->IDENTIFIER
Declaration
	initRuleAction{
		at.jku.weiner.c.Scope.setTypedef(false);
	}
	afterRuleAction{
		at.jku.weiner.c.Log.log("Declaration-leave");
	}
	:
	{Declaration}
	(
		specifiers=DeclarationSpecifiers 
		(initDeclaratorList+=InitDeclaratorList)? 
		semi=SEMI
	//|	staticAssertDeclaration
	)
;

DeclarationSpecifiers
initRuleAction{
	at.jku.weiner.c.Log.log("DeclarationSpecifiers-enter");
	} 
	afterRuleAction{
		at.jku.weiner.c.Log.log("DeclarationSpecifiers-leave");
	}
	:
	{DeclarationSpecifiers}
	 
	(declarationSpecifier+=StorageClassSpecifier
	|	declarationSpecifier+=TypeSpecifier
	|	declarationSpecifier+=TypeQualifier
	//|	declarationSpecifier+=functionSpecifier
	//|	declarationSpecifier+=alignmentSpecifier
	)+
;

InitDeclaratorList
	initRuleAction{
		at.jku.weiner.c.Log.log("InitDeclaratorList-enter");
	} 
	afterRuleAction{
		at.jku.weiner.c.Log.log("InitDeclaratorList-leave");
	}
	:
	{InitDeclaratorList}
	
	initDeclarator+=InitDeclarator
	(COMMA initDeclarator2+=InitDeclarator)*
;

InitDeclarator
	initRuleAction{
		at.jku.weiner.c.Log.log("InitDeclarator-enter");
	} 
	afterRuleAction{
		at.jku.weiner.c.Log.log("InitDeclarator-leave");
	}
	:
	{InitDeclarator}
	
	declarator=Declarator
	(ASSIGN initializer=Initializer)?
;

StorageClassSpecifier
	initRuleAction{
		at.jku.weiner.c.Log.log("StorageClassSpecifier-enter");
	} 
	afterRuleAction{
		at.jku.weiner.c.Log.log("StorageClassSpecifier-leave");
	}
	:
	{StorageClassSpecifier}
	(	class=KW_TYPEDEF
			postAction{{ at.jku.weiner.c.Scope.setTypedef(true);  }}
	|	class=KW_EXTERN
	|	class=KW_STATIC
	|	class=KW_THREADLOCAL
	|	class=KW_AUTO
	|	class=KW_REGISTER
	)
;

TypeSpecifier
	initRuleAction{
		at.jku.weiner.c.Log.log("TypeSpecifier-enter");
	} 
	afterRuleAction{
		at.jku.weiner.c.Log.log("TypeSpecifier-leave");
	}
	:
	{TypeSpecifier}
	
	name=KW_VOID
	|	name=KW_CHAR
	|	name=KW_SHORT
	|	name=KW_INT postAction{ { at.jku.weiner.c.Log.log("found kw_int"); } }
	|	name=KW_LONG
	|	name=KW_FLOAT
	|	name=KW_DOUBLE postAction{ { at.jku.weiner.c.Log.log("found kw_double"); } }
	|	name=KW_SIGNED
	|	name=KW_UNSIGNED
	|	name=KW_BOOL
	|	name=KW_COMPLEX
	|	name='__m128'
	|	name='__m128d'
	|	name='__m128i'
	
	// |	'__extension__' LEFTPAREN ('__m128' | '__m128d' | '__m128i') RIGHTPAREN
  //  |	specifier=atomicTypeSpecifier
	// |	specifier=structOrUnionSpecifier
	// |	specifier=enumSpecifier
	|  type=TypedefName
	// |	'__typeof__' LEFTPAREN constExrp=constantExpression RIGHTPAREN // GCC extension
	
;

TypedefName
	initRuleAction{
		at.jku.weiner.c.Log.log("TypedefName-enter");
	} 
	afterRuleAction{
		at.jku.weiner.c.Log.log("TypedefName-leave");
	}
	:
	{TypedefName}
	id=ID
		preAction{ { at.jku.weiner.c.Scope.isTypeName(input.LT(1).getText()) }? }
;

/*structOrUnionSpecifier returns declarationSpecifier:
	{structOrUnionSpecifier}
	(structOrUnion IDENTIFIER? LEFTBRACE structDeclList=structDeclarationList RIGHTBRACE
	|	structOrUnion IDENTIFIER
	)
;

structOrUnion: STRUCT
	|	UNION
;

structDeclarationList: (structDeclaration+=structDeclaration)+
;

structDeclaration:
	specifierQualifierList (structDeclarationList+=structDeclaratorList)? SEMI
	|	staticAssertDeclaration
;



SpecifierQualifierList:
	{SpecifierQualifierList} 
	(typeSpecifier+=TypeSpecifier | typeQualifier+=TypeQualifier)+
	//(specQualifierList+=specifierQualifierList?)
;

/*
structDeclaratorList: structDeclarator=structDeclarator (COMMA structDeclarator2+=structDeclarator)*;

structDeclarator: declarator=declarator (COLON constExpr+=constantExpression)?
	| (COLON constExpr+=constantExpression)
;

enumSpecifier returns declarationSpecifier:
	{enumSpecifier} 
	(	
		(ENUM IDENTIFIER? LEFTBRACE enumList=enumeratorList) (RIGHTBRACE | COMMA RIGHTBRACE)
	|	ENUM IDENTIFIER
	)
;

enumeratorList: enumerator
	(COMMA enumerator+=enumerator)*
;

enumerator:
	{enumerator} 
	enumerationCONSTANT
	(ASSIGN constExpr=constantExpression)?
;

atomicTypeSpecifier returns declarationSpecifier:
	ATOMIC LEFTPAREN typeName RIGHTPAREN
;
*/

TypeQualifier
	initRuleAction{
		at.jku.weiner.c.Log.log("TypeQualifier-enter");
	} 
	afterRuleAction{
		at.jku.weiner.c.Log.log("TypeQualifier-leave");
	}
	:
	{TypeQualifier} 
	(	type=KW_CONST
	|	type=KW_RESTRICT
	|	type=KW_VOLATILE
	|	type=KW_ATOMIC
	)
;

/*
functionSpecifier:
	{functionSpecifier} 
	(
		(INLINE
		|	NORETURN
		|	'__inline__' // GCC extension
		|	'__stdcall'
		)
		|	gccAttributeSpecifier=gccAttributeSpecifier
		|	'__declspec' LEFTPAREN IDENTIFIER RIGHTPAREN
	)
;

alignmentSpecifier: ALIGNAS LEFTPAREN (typeName | constantExpression) RIGHTPAREN;
*/

Declarator
	initRuleAction{
		at.jku.weiner.c.Log.log("Declarator-enter");
	} 
	afterRuleAction{
		at.jku.weiner.c.Log.log("Declarator-leave");
	}
	:
	{Declarator}	
	/*pointer?*/
	(declarator=DirectDeclarator)
	//(gccDeclExt+=gccDeclaratorExtension)*
;

DirectDeclarator
	initRuleAction{
		at.jku.weiner.c.Log.log("DirectDeclarator-enter");
	} 
	afterRuleAction{
		at.jku.weiner.c.Log.log("DirectDeclarator-leave");
	}
	:
	{DirectDeclarator}
	(id=ID
		preAction{ {
			at.jku.weiner.c.Scope.setTemp(input);
		} }
		postAction{ {
			at.jku.weiner.c.Scope.addTypedefIfIsTypedef();
		} }
	| LEFTPAREN declarator=Declarator RIGHTPAREN
	)
	(declaratorSuffix+=DeclaratorSuffix)*	
;

DeclaratorSuffix:
	{DeclaratorSuffix}
	(
	/*LEFTBRACKET STATIC (typeQualifierList+=typeQualifierList)? (assignExpr+=assignmentExpression)? RIGHTBRACKET
	|	LEFTBRACKET  (typeQualifierList+=typeQualifierList)? (assignExpr+=assignmentExpression) RIGHTBRACKET
	|	LEFTBRACKET (typeQualifierList+=typeQualifierList) STATIC (assignExpr+=assignmentExpression) RIGHTBRACKET
	|	LEFTBRACKET (typeQualifierList+=typeQualifierList)? STAR RIGHTBRACKET
	|*/	lastSuffix=DirectDeclaratorLastSuffix
	)
;


DirectDeclaratorLastSuffix:
	{DirectDeclaratorLastSuffix}
	 LEFTPAREN
		(
			(parameterTypeList+=ParameterTypeList)
			|
			(identifierList=IdentifierList)?
		)
	RIGHTPAREN
;

/*
gccDeclaratorExtension:
	{gccDeclaratorExtension} '__asm' LEFTPAREN STRINGLITERAL+ RIGHTPAREN
	| {gccDeclaratorExtension} gccAttributeSpecifier=gccAttributeSpecifier
;


gccAttributeSpecifier: '__attribute__' LEFTPAREN LEFTPAREN list=gccAttributeList RIGHTPAREN RIGHTPAREN;
gccAttributeList: gcAttribute=gccAttribute (COMMA gccAttribute+=gccAttribute)*;
	//|	// empty;

// enter gccAttribute and nestedParenthesesBlock here
gccAttribute: {gccAttribute} (ANYOTHER)
	// relaxed def for "identifier or reserved word"
		(LEFTPAREN list=argumentExpressionList? RIGHTPAREN)?
	// |	//empty
;

//nestedParenthesesBlock: (	NOPAREN
//		|	LEFTPAREN nestedParenthesesBlock RIGHTPAREN
//		)*
//;

pointer: {pointer} ((STAR | CARET) typeQualifierList+=typeQualifierList?)*
	//|	{pointer} CARET typeQualifierList=typeQualifierList? pointer=pointer?// Blocks language extension
;

typeQualifierList: {typeQualifierList} (typeQualifier+=typeQualifier)+;
*/
ParameterTypeList:
	{ParameterTypeList}
	list=ParameterList
	(COMMA ELLIPSIS)?
;

ParameterList:
	{ParameterList} 
	parameterDeclaration+=ParameterDeclaration
	(COMMA parameterDeclaration+=ParameterDeclaration)*
;

ParameterDeclaration:
	{ParameterDeclaration}
	declSpecifiers=DeclarationSpecifiers
	(declarator=Declarator
		//	|
		//	(abstractDeclator=AbstractDeclarator)
	)?
;

IdentifierList:
	{IdentifierList} 
	id+=MyIdentifier (COMMA id+=MyIdentifier)*
;

MyIdentifier:
	{MyIdentifier}
	id=ID
;

//TypeName: SpecifierQualifierList (abstractDeclarator+=AbstractDeclarator)?;

/*
AbstractDeclarator:
	{AbstractDeclarator} 
	//pointer
	//(directAbstractDeclarator=DirectAbstractDeclarator)?
	//(gccDeclExtAbstract+=gccDeclaratorExtension)*
	//| 
	(directAbstractDeclarator=DirectAbstractDeclarator)
	//(gccDeclExtAbstract+=gccDeclaratorExtension)*
;
*/

/*
DirectAbstractDeclarator returns AbstractDeclarator:
	{DirectAbstractDeclarator}
	(LEFTPAREN declarator=AbstractDeclarator RIGHTPAREN
		//(gccDeclExt+=gccDeclaratorExtension)*
	|	abstractDeclaratorSuffix+=AbstractDeclaratorSuffix
	)
	
	//(abstractDeclaratorSuffix+=abstractDeclaratorSuffix)*
;
*/

/*
abstractDeclaratorSuffix: {abstractDeclaratorSuffix}
	(LEFTBRACKET typeQualifierList=typeQualifierList? (assignmentExpr+=assignmentExpression)? RIGHTBRACKET
	|	LEFTBRACKET STATIC typeQualifierList=typeQualifierList? (assignmentExpr+=assignmentExpression) RIGHTBRACKET
	|	LEFTBRACKET typeQualifierListOrig=typeQualifierList STATIC assignmentExpr+=assignmentExpression RIGHTBRACKET
	|	LEFTBRACKET STAR RIGHTBRACKET
	|	LEFTPAREN parameterTypeList=parameterTypeList? RIGHTPAREN (gccDeclExt+=gccDeclaratorExtension)*
	)
;
*/


Initializer:
	expr=AssignmentExpression
	//|	LEFTBRACE initializerList COMMA? RIGHTBRACE
;

/*
initializerList: designation? (initializer=initializer)
	(COMMA (designation+=designation)? (initializerMore+=initializer))*
;
*/

/*** Statements */
Statement:
	{Statement}
	(
	//stmt=labeledStatement
	//|
		stmt=CompoundStatement
	|	stmt=ExpressionStatement
/*	|	stmt=selectionStatement
	|	stmt=iterationStatement
	*/
	| stmt=JumpStatement /*
	|	('__asm' | '__asm__') (VOLATILE | '__volatile__') 
			LEFTPAREN (expr+=logicalOrExpression (COMMA logicalExpr+=logicalOrExpression)*)? 
			(COLON (expr+=logicalOrExpression (COMMA logicalExpr+=logicalOrExpression)*)?)* RIGHTPAREN SEMI
 */
		)
;
/*
labeledStatement returns statement:
	IDENTIFIER COLON statement
	|	CASE constantExpression COLON statement=statement
	|	DEFAULT COLON statement
;
*/

CompoundStatement returns Statement:
	{CompoundStatement}
	LEFTBRACE
		body=BodyStatement
	RIGHTBRACE
;

BodyStatement returns Statement:
	{BodyStatement}
	(blockList+=BlockList)?
;

BlockList:
	{BlockList}
	(declaration+=Declaration | statement+=Statement)+
;

ExpressionStatement:
	{ExpressionStatement} 
	(expression = Expression)? 
	semi=SEMI
;

/*
selectionStatement:
	IF LEFTPAREN expression RIGHTPAREN statement=statement
	(=>ELSE elseStatement+=statement)?
	|	SWITCH LEFTPAREN expression RIGHTPAREN statement=statement
;

iterationStatement: WHILE LEFTPAREN expression RIGHTPAREN statement=statement
	|	DO statement WHILE LEFTPAREN whileexpression=expression RIGHTPAREN SEMI
	|	FOR LEFTPAREN expression? SEMI expression? SEMI expression? RIGHTPAREN statement
	|	FOR LEFTPAREN declaration (forexpression+=expression)? SEMI expression? RIGHTPAREN statement=statement
;*/

JumpStatement:
	{JumpStatement}
	(
	//GOTO IDENTIFIER SEMI //(can be reached over GOTO unaryExpression)
	//|	CONTINUE SEMI
	//|	BREAK SEMI
	//|
	KW_RETURN expr=Expression? semi=SEMI
	//|	GOTO expr=unaryExpression SEMI // GCC extension
	)
;

/*
designation: designatorList ASSIGN;

designatorList: designator (designator+=designator)*;

designator: {designator} LEFTBRACKET expr=constantExpression RIGHTBRACKET
	|	{designator} DOT IDENTIFIER
;

staticAssertDeclaration: STATICASSERT LEFTPAREN constantExpression COMMA STRINGLITERAL+ RIGHTPAREN SEMI;

declarationList: 
	(declaration+=declaration)+
;
*/

/*** Expressions ***/
Expression:
	{Expression}
	exprExpr+=AssignmentExpression
	(COMMA exprExpr+=AssignmentExpression)*
;

AssignmentExpression returns Expression:
	{AssignmentExpression}
	(
		expr=ConditionalExpression
	/*|
		(expr=UnaryExpression
		op=AssignmentOperator
		assignmentExpr+=AssignmentExpression
		)
	*/
	)
;

AssignmentOperator:
	{AssignmentOperator}
		op=ASSIGN
	| 	op=STARASSIGN
	| 	op=DIVASSIGN
	| 	op=MODASSIGN
	| 	op=PLUSASSIGN
	| 	op=MINUSASSIGN
	| 	op=LEFTSHIFTASSIGN
	| 	op=RIGHTSHIFTASSIGN
	| 	op=ANDASSIGN
	| 	op=XORASSIGN
	| 	op=ORASSIGN
;

ConditionalExpression returns Expression:
	{ConditionalExpression}
	expr=LogicalOrExpression
	(QUESTION qExpr=Expression COLON
		cExpr=ConditionalExpression
	)?
;

LogicalOrExpression returns Expression:
	{LogicalOrExpression}
	expr+=LogicalAndExpression
	(OROR expr+=LogicalAndExpression)*
;

LogicalAndExpression returns Expression:
	{LogicalAndExpression}
	expr+=InclusiveOrExpression
	(ANDAND expr+=InclusiveOrExpression)*
;

InclusiveOrExpression returns Expression:
	{InclusiveOrExpression}
	expr+=ExclusiveOrExpression
	(OR expr+=ExclusiveOrExpression)*
;

ExclusiveOrExpression returns Expression:
	{ExclusiveOrExpression}
	expr+=AndExpression
	(CARET expr+=AndExpression)*
;

AndExpression returns Expression:
	{AndExpression}
	expr+=EqualityExpression
	(AND expr+=EqualityExpression)*
;

EqualityExpression returns Expression:
	{EqualityExpression}
	expr+=RelationalExpression
	((op+=EQUAL | op+=NOTEQUAL) expr+=RelationalExpression)*
;

RelationalExpression returns Expression:
	{RelationalExpression}
	expr+=ShiftExpression
	((op+=LESS|op+=GREATER|op+=LESSEQUAL|op+=GREATEREQUAL)
		expr += ShiftExpression
	)*
;

ShiftExpression returns Expression:
	{ShiftExpression}
	expr+=AdditiveExpression
	((op+=LEFTSHIFT| op+=RIGHTSHIFT)
		expr+=AdditiveExpression
	)*
;

AdditiveExpression returns Expression:
	{AdditiveExpression}
	expr+=MultiplicativeExpression
	((op+=PLUS| op+=MINUS)
		expr+=MultiplicativeExpression
	)*
;

MultiplicativeExpression returns Expression:
	{MultiplicativeExpression}
	expr+=CastExpression
	((op+=STAR|op+=DIV|op+=MOD)
		expr+=CastExpression
	)*
;

CastExpression returns Expression:
	{CastExpression}
	(
	expr=UnaryExpression
	//|	LEFTPAREN type=TypeName RIGHTPAREN castExpr=CastExpression
	//|	'__extension__' LEFTPAREN type=TypeName RIGHTPAREN castExpr=CastExpression
	)
;

UnaryExpression returns Expression:
	{UnaryExpression}	
	//(PLUSPLUS | MINUSMINUS | SIZEOF)*
	(
		expr=PostfixExpression
	//|	SIZEOF LEFTPAREN typeName=typeName RIGHTPAREN
	//|	ALIGNOF LEFTPAREN typeName=typeName RIGHTPAREN
	|	ANDAND ID // GCC extension address of label
	|	op=UnaryOperator expr=CastExpression
	)
	//|	PLUSPLUS unaryExpr=unaryExpression
	//|	MINUSMINUS unaryExpr=unaryExpression
	//|	SIZEOF unaryExpr=unaryExpression 
;

UnaryOperator:
		op=AND
	|	op=STAR
	|	op=PLUS 
	|	op=MINUS 
	|	op=TILDE
	|	op=NOT
;

PostfixExpression returns Expression:
	{PostfixExpression}
	(expr+=PrimaryExpression
	/*	(
	|	('__extension__' LEFTPAREN typeName RIGHTPAREN LEFTBRACE initializerList=initializerList) 
			(COMMA? RIGHTBRACE)
	)
	(LEFTBRACKET expr+=expression RIGHTBRACKET
	| LEFTPAREN argumentExpressionList+=argumentExpressionList? RIGHTPAREN
	| DOT IDENTIFIER
	| ARROW IDENTIFIER
	| PLUSPLUS
	| MINUSMINUS
	
	)*
	*/
	)
;

/*
argumentExpressionList: assignmentExpression (COMMA expr+=assignmentExpression)*;
*/

PrimaryExpression returns Expression:
	{PrimaryExpression}
	(id=ID
	|	const=Constant
	//|	string+=STRING_LITERAL+
	|	LEFTPAREN expr=Expression RIGHTPAREN
	//|	genericSelection=genericSelection
	// |	'__extension__'? LEFTPAREN compoundStmt=compoundStatement RIGHTPAREN // Blocks (GCC extension)
	//|	'__builtin_va_arg' LEFTPAREN expr=unaryExpression COMMA typeName=typeName RIGHTPAREN
	//|	'__builtin_offsetof' LEFTPAREN typeName=typeName COMMA expr=unaryExpression RIGHTPAREN
	)
;

Constant:
	{Constant}
		hex=HEX_LITERAL
	|	oct=OCTAL_LITERAL
	|	dec=DECIMAL_LITERAL
	|	ch=CHAR_LITERAL
	|	str=STRING_LITERAL
	|	float=FLOAT_LITERAL
;

/*** UNKNOWN!!! ***/

/*
genericSelection: GENERIC LEFTPAREN assignmentExpression COMMA genericAssocList=genericAssocList RIGHTPAREN;

genericAssocList: genericAssociation (COMMA genericAssociation+=genericAssociation)*;

genericAssociation:
	(typeName | DEFAULT) COLON
	(assignmentExpression=assignmentExpression)
;
*/

/*ConstantExpression returns Expression:
	{ConstantExpression}
	expr=ConditionalExpression
;*/

/*** lexer ***/
/*** start with keywords ;-) */
terminal KW_UNDERSCORE: '_';

terminal KW_AUTO : 'auto';
terminal KW_BREAK : 'break';
terminal KW_CASE : 'case';
terminal KW_CHAR : 'char';
terminal KW_CONST : 'const';
terminal KW_CONTINUE : 'continue';
terminal KW_DEFAULT : 'default';
terminal KW_DO : 'do';
terminal KW_DOUBLE : 'double';
terminal KW_ELSE : 'else';
terminal KW_ENUM : 'enum';
terminal KW_EXTERN : 'extern';
terminal KW_FLOAT : 'float';
terminal KW_FOR : 'for';
terminal KW_GOTO : 'goto';
terminal KW_IF : 'if';
terminal KW_INLINE : 'inline';
terminal KW_INT : 'int';
terminal KW_LONG : 'long';
terminal KW_REGISTER : 'register';
terminal KW_RESTRICT : 'restrict';
terminal KW_RETURN : 'return';
terminal KW_SHORT : 'short';
terminal KW_SIGNED : 'signed';
terminal KW_SIZEOF : 'sizeof';
terminal KW_STATIC : 'static';
terminal KW_STRUCT : 'struct';
terminal KW_SWITCH : 'switch';
terminal KW_TYPEDEF : 'typedef';
terminal KW_UNION : 'union';
terminal KW_UNSIGNED : 'unsigned';
terminal KW_VOID : 'void';
terminal KW_VOLATILE : 'volatile';
terminal KW_WHILE : 'while';

terminal KW_ALIGNAS : '_Alignas';
terminal KW_ALIGNOF : '_Alignof';
terminal KW_ASM: 'asm';
terminal KW_ATOMIC : '_Atomic';
terminal KW_BOOL : '_Bool';
terminal KW_COMPLEX : '_Complex';
terminal KW_GENERIC : '_Generic';
terminal KW_IMAGINARY : '_Imaginary';
terminal KW_NORETURN : '_Noreturn';
terminal KW_STATICASSERT : '_Static_assert';
terminal KW_THREADLOCAL : '_Thread_local';
terminal KW_PRAGMA: 'pragma';

terminal LEFTPAREN: '(';
terminal RIGHTPAREN: ')';
terminal LEFTBRACKET: '[';
terminal RIGHTBRACKET: ']';
terminal LEFTBRACE: '{';
terminal RIGHTBRACE: '}';
terminal LESS: '<';
terminal LESSEQUAL: LESS ASSIGN;
terminal GREATER: '>';
terminal GREATEREQUAL: GREATER ASSIGN;
terminal LEFTSHIFT: LESS LESS;
terminal RIGHTSHIFT: GREATER GREATER;

terminal PLUS: '+';
terminal PLUSPLUS: PLUS PLUS;
terminal MINUS: '-';
terminal MINUSMINUS: MINUS MINUS;
terminal STAR: '*';
terminal DIV: '/';
terminal MOD: '%';

terminal AND: '&';
terminal ANDAND: AND AND;
terminal OR: '|';
terminal OROR: OR OR;
terminal CARET: '^';
terminal NOT: '!';
terminal TILDE: '~';

terminal QUESTION: '?';
terminal COLON: ':';
terminal SEMI: ';';
terminal COMMA: ',';
terminal ASSIGN: '=';

terminal STARASSIGN: STAR ASSIGN;
terminal DIVASSIGN: DIV ASSIGN;
terminal MODASSIGN: MOD ASSIGN;
terminal PLUSASSIGN: PLUS ASSIGN;
terminal MINUSASSIGN: MINUS ASSIGN;
terminal LEFTSHIFTASSIGN: LEFTSHIFT ASSIGN;
//'>>='
terminal RIGHTSHIFTASSIGN:RIGHTSHIFT ASSIGN;
terminal ANDASSIGN: AND ASSIGN;
terminal XORASSIGN: CARET ASSIGN;
terminal ORASSIGN: OR ASSIGN;

terminal EQUAL: ASSIGN ASSIGN;
terminal NOTEQUAL: NOT ASSIGN;

terminal ARROW: MINUS GREATER;
terminal DOT: '.';
terminal ELLIPSIS: DOT DOT DOT;

//terminal ZERO: '0';
terminal SINGLEQUOTE: '\'';
terminal DOUBLEQUOTE: '"';
terminal BACKSLASH: '\\';

terminal ID: IDENTIFIER;
terminal fragment IDENTIFIER:
	LETTER (LETTER|'0'..'9')*
;
	
terminal fragment LETTER:
	'$'
	|	'A'..'Z'
	|	'a'..'z'
	|	'_'
;

terminal CHAR_LITERAL:
	'\'' ( ESCAPE_SEQUENCE | !('\''|'\\') ) '\''
;

terminal STRING_LITERAL:
	'"' ( ESCAPE_SEQUENCE | !('\\'|'"') )* '"'
;

terminal HEX_LITERAL: '0' ('x'|'X') HEX_DIGIT+ INTEGER_TYPE_SUFFIX? ;

terminal DECIMAL_LITERAL: ('0' | '1'..'9' '0'..'9'*) INTEGER_TYPE_SUFFIX? ;

terminal OCTAL_LITERAL: '0' ('0'..'7')+ INTEGER_TYPE_SUFFIX? ;

terminal fragment HEX_DIGIT: ('0'..'9'|'a'..'f'|'A'..'F');

terminal fragment INTEGER_TYPE_SUFFIX:
	('u'|'U')? ('l'|'L')
	|	('u'|'U')  ('l'|'L')?
;

terminal FLOAT_LITERAL:
	('0'..'9')+ '.' ('0'..'9')* EXPONENT? FLOAT_TYPE_SUFFIX?
	|	'.' ('0'..'9')+ EXPONENT? FLOAT_TYPE_SUFFIX?
	|	('0'..'9')+ EXPONENT FLOAT_TYPE_SUFFIX?
	|	('0'..'9')+ EXPONENT? FLOAT_TYPE_SUFFIX
;

terminal fragment EXPONENT:
	('e'|'E') ('+'|'-')? ('0'..'9')+
;

terminal fragment FLOAT_TYPE_SUFFIX: ('f'|'F'|'d'|'D') ;

terminal fragment ESCAPE_SEQUENCE:
	'\\' ('b'|'t'|'n'|'f'|'r'|'\"'|'\''|'\\')
	|	OCTAL_ESCAPE
;

terminal fragment OCTAL_ESCAPE:
	'\\' ('0'..'3') ('0'..'7') ('0'..'7')
	|	'\\' ('0'..'7') ('0'..'7')
	|	'\\' ('0'..'7')
;

terminal fragment UNICODE_ESCAPE:
	'\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
;

terminal LINEDIRECTIVE: 
	'#' WHITESPACE? DECIMAL_LITERAL WHITESPACE? STRING_LITERAL (!NEWLINE)*;
terminal PRAGMADIRECTIVE: '#' WHITESPACE? KW_PRAGMA WHITESPACE (!NEWLINE)*;
terminal WHITESPACE: (' ' | '\t')+;
terminal BLOCK_COMMENT: '/*' -> '*/';
terminal LINE_COMMENT: '//' (!NEWLINE)*;
terminal NEWLINE: ('\r'|'\n');
//terminal EOF_TERMINAL: EOF;

//terminal ANYOTHER: !(COMMA | LEFTPAREN | RIGHTPAREN);
//terminal NOPAREN: !(LEFTPAREN | RIGHTPAREN);
