
/*
 * generated by Xtext 2.9.0-SNAPSHOT
 */
lexer grammar InternalCPreprocessLexer;

options {
	backtrack=true;
	memoize=true;
}

tokens {
	RULE_HASH;
	RULE_INCLUDE;
	RULE_DEFINE;
	RULE_ERROR;
	RULE_UNDEF;
	RULE_PRAGMA;
	RULE_LPAREN;
	RULE_RPAREN;
	RULE_COMMA;
	RULE_LINEFEED;
	RULE_CARRIAGERETURN;
	RULE_NEWLINE;
	RULE_BACKSLASH;
	RULE_LINEBREAK;
	RULE_SPACE;
	RULE_TAB;
	RULE_WS;
	RULE_ID;
	RULE_ID_NONDIGIT;
	RULE_DIGIT;
	RULE_NONDIGIT_LETTER;
	RULE_UNIVERSAL_CHARACTER;
	RULE_HEX_QUAD;
	RULE_HEXADECIMAL_DIGIT;
	RULE_SPECIAL;
}

@header {
package at.jku.weiner.cpreprocess.parser.antlr.lexer;

// Hack: Use our own Lexer superclass by means of import. 
// Currently there is no other way to specify the superclass for the lexer.
import org.eclipse.xtext.parser.antlr.Lexer;
}



SYNTHETIC_ALL_KEYWORDS :
	(FRAGMENT_RULE_HASH)=> FRAGMENT_RULE_HASH {$type = RULE_HASH; } |
	(FRAGMENT_RULE_INCLUDE)=> FRAGMENT_RULE_INCLUDE {$type = RULE_INCLUDE; } |
	(FRAGMENT_RULE_DEFINE)=> FRAGMENT_RULE_DEFINE {$type = RULE_DEFINE; } |
	(FRAGMENT_RULE_ERROR)=> FRAGMENT_RULE_ERROR {$type = RULE_ERROR; } |
	(FRAGMENT_RULE_UNDEF)=> FRAGMENT_RULE_UNDEF {$type = RULE_UNDEF; } |
	(FRAGMENT_RULE_PRAGMA)=> FRAGMENT_RULE_PRAGMA {$type = RULE_PRAGMA; } |
	(FRAGMENT_RULE_LPAREN)=> FRAGMENT_RULE_LPAREN {$type = RULE_LPAREN; } |
	(FRAGMENT_RULE_RPAREN)=> FRAGMENT_RULE_RPAREN {$type = RULE_RPAREN; } |
	(FRAGMENT_RULE_COMMA)=> FRAGMENT_RULE_COMMA {$type = RULE_COMMA; } |
	(FRAGMENT_RULE_NEWLINE)=> FRAGMENT_RULE_NEWLINE {$type = RULE_NEWLINE; } |
	(FRAGMENT_RULE_WS)=> FRAGMENT_RULE_WS {$type = RULE_WS; } |
	(FRAGMENT_RULE_ID)=> FRAGMENT_RULE_ID {$type = RULE_ID; } |
	(FRAGMENT_RULE_SPECIAL)=> FRAGMENT_RULE_SPECIAL {$type = RULE_SPECIAL; } ;


// Rules duplicated to allow inter-rule references

fragment RULE_HASH : FRAGMENT_RULE_HASH;
fragment FRAGMENT_RULE_HASH : '#';

fragment RULE_INCLUDE : FRAGMENT_RULE_INCLUDE;
fragment FRAGMENT_RULE_INCLUDE : 'include';

fragment RULE_DEFINE : FRAGMENT_RULE_DEFINE;
fragment FRAGMENT_RULE_DEFINE : 'define';

fragment RULE_ERROR : FRAGMENT_RULE_ERROR;
fragment FRAGMENT_RULE_ERROR : 'error';

fragment RULE_UNDEF : FRAGMENT_RULE_UNDEF;
fragment FRAGMENT_RULE_UNDEF : 'undef';

fragment RULE_PRAGMA : FRAGMENT_RULE_PRAGMA;
fragment FRAGMENT_RULE_PRAGMA : 'pragma';

fragment RULE_LPAREN : FRAGMENT_RULE_LPAREN;
fragment FRAGMENT_RULE_LPAREN : '(';

fragment RULE_RPAREN : FRAGMENT_RULE_RPAREN;
fragment FRAGMENT_RULE_RPAREN : ')';

fragment RULE_COMMA : FRAGMENT_RULE_COMMA;
fragment FRAGMENT_RULE_COMMA : ',';

fragment RULE_LINEFEED : '\n';

fragment RULE_CARRIAGERETURN : '\r';

fragment RULE_NEWLINE : FRAGMENT_RULE_NEWLINE;
fragment FRAGMENT_RULE_NEWLINE : (RULE_CARRIAGERETURN|RULE_LINEFEED);

fragment RULE_BACKSLASH : '\\';

fragment RULE_LINEBREAK : RULE_BACKSLASH RULE_NEWLINE;

fragment RULE_SPACE : ' ';

fragment RULE_TAB : '\t';

fragment RULE_WS : FRAGMENT_RULE_WS;
fragment FRAGMENT_RULE_WS : (RULE_SPACE|RULE_TAB|RULE_LINEBREAK);

fragment RULE_ID : FRAGMENT_RULE_ID;
fragment FRAGMENT_RULE_ID : RULE_ID_NONDIGIT (RULE_ID_NONDIGIT|RULE_DIGIT)*;

fragment RULE_ID_NONDIGIT : (RULE_NONDIGIT_LETTER|RULE_UNIVERSAL_CHARACTER);

fragment RULE_DIGIT : '0'..'9';

fragment RULE_NONDIGIT_LETTER : ('a'..'z'|'A'..'Z'|'_');

fragment RULE_UNIVERSAL_CHARACTER : ('\\u' RULE_HEX_QUAD|'\\U' RULE_HEX_QUAD RULE_HEX_QUAD);

fragment RULE_HEX_QUAD : RULE_HEXADECIMAL_DIGIT RULE_HEXADECIMAL_DIGIT RULE_HEXADECIMAL_DIGIT RULE_HEXADECIMAL_DIGIT;

fragment RULE_HEXADECIMAL_DIGIT : ('0'..'9'|'a'..'f'|'A'..'F');

fragment RULE_SPECIAL : FRAGMENT_RULE_SPECIAL;
fragment FRAGMENT_RULE_SPECIAL : .;



