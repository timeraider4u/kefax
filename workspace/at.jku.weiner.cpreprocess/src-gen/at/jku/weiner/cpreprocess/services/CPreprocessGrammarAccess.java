/*
 * generated by Xtext 2.9.0-SNAPSHOT
 */
package at.jku.weiner.cpreprocess.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractParserRuleElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class CPreprocessGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.weiner.cpreprocess.CPreprocess.Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cModelAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cUnitsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cUnitsTranslationUnitParserRuleCall_1_0 = (RuleCall)cUnitsAssignment_1.eContents().get(0);
		
		//Model:
		//	{Model} units+=TranslationUnit;
		@Override public ParserRule getRule() { return rule; }
		
		//{Model} units+=TranslationUnit
		public Group getGroup() { return cGroup; }
		
		//{Model}
		public Action getModelAction_0() { return cModelAction_0; }
		
		//units+=TranslationUnit
		public Assignment getUnitsAssignment_1() { return cUnitsAssignment_1; }
		
		//TranslationUnit
		public RuleCall getUnitsTranslationUnitParserRuleCall_1_0() { return cUnitsTranslationUnitParserRuleCall_1_0; }
	}
	public class TranslationUnitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.weiner.cpreprocess.CPreprocess.TranslationUnit");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTranslationUnitAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cLinesAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cLinesNewLineLineParserRuleCall_1_0_0 = (RuleCall)cLinesAssignment_1_0.eContents().get(0);
		private final Assignment cLinesAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cLinesCodeParserRuleCall_1_1_0 = (RuleCall)cLinesAssignment_1_1.eContents().get(0);
		
		//TranslationUnit:
		//	{TranslationUnit} (lines+=NewLineLine
		//	| lines+=Code)*;
		@Override public ParserRule getRule() { return rule; }
		
		//{TranslationUnit} (lines+=NewLineLine | lines+=Code)*
		public Group getGroup() { return cGroup; }
		
		//{TranslationUnit}
		public Action getTranslationUnitAction_0() { return cTranslationUnitAction_0; }
		
		//(lines+=NewLineLine | lines+=Code)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		////	lines+=PreprocessorDirectives
		////|
		//lines+=NewLineLine
		public Assignment getLinesAssignment_1_0() { return cLinesAssignment_1_0; }
		
		//NewLineLine
		public RuleCall getLinesNewLineLineParserRuleCall_1_0_0() { return cLinesNewLineLineParserRuleCall_1_0_0; }
		
		//lines+=Code
		public Assignment getLinesAssignment_1_1() { return cLinesAssignment_1_1; }
		
		//Code
		public RuleCall getLinesCodeParserRuleCall_1_1_0() { return cLinesCodeParserRuleCall_1_1_0; }
	}
	public class PreprocessorDirectivesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.weiner.cpreprocess.CPreprocess.PreprocessorDirectives");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPreprocessorDirectivesAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cHASHTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cDirectiveAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDirectiveIncludeDirectiveParserRuleCall_2_0 = (RuleCall)cDirectiveAssignment_2.eContents().get(0);
		private final RuleCall cNEWLINETerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//PreprocessorDirectives SourceCodeLine:
		//	{PreprocessorDirectives} HASH
		//	directive=IncludeDirective
		//	NEWLINE
		@Override public ParserRule getRule() { return rule; }
		
		//{PreprocessorDirectives} HASH directive=IncludeDirective NEWLINE
		public Group getGroup() { return cGroup; }
		
		//{PreprocessorDirectives}
		public Action getPreprocessorDirectivesAction_0() { return cPreprocessorDirectivesAction_0; }
		
		//HASH
		public RuleCall getHASHTerminalRuleCall_1() { return cHASHTerminalRuleCall_1; }
		
		//directive=IncludeDirective
		public Assignment getDirectiveAssignment_2() { return cDirectiveAssignment_2; }
		
		//IncludeDirective
		public RuleCall getDirectiveIncludeDirectiveParserRuleCall_2_0() { return cDirectiveIncludeDirectiveParserRuleCall_2_0; }
		
		//NEWLINE
		public RuleCall getNEWLINETerminalRuleCall_3() { return cNEWLINETerminalRuleCall_3; }
	}
	public class IncludeDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.weiner.cpreprocess.CPreprocess.IncludeDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIncludeDirectiveAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cIncludeKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStringAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStringNEWLINETerminalRuleCall_2_0 = (RuleCall)cStringAssignment_2.eContents().get(0);
		
		//IncludeDirective:
		//	{IncludeDirective}
		//	'include' string=NEWLINE;
		@Override public ParserRule getRule() { return rule; }
		
		//{IncludeDirective} 'include' string=NEWLINE
		public Group getGroup() { return cGroup; }
		
		//{IncludeDirective}
		public Action getIncludeDirectiveAction_0() { return cIncludeDirectiveAction_0; }
		
		//'include'
		public Keyword getIncludeKeyword_1() { return cIncludeKeyword_1; }
		
		//string=NEWLINE
		public Assignment getStringAssignment_2() { return cStringAssignment_2; }
		
		//NEWLINE
		public RuleCall getStringNEWLINETerminalRuleCall_2_0() { return cStringNEWLINETerminalRuleCall_2_0; }
	}
	public class NewLineLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.weiner.cpreprocess.CPreprocess.NewLineLine");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNewLineLineAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cNEWLINETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//NewLineLine SourceCodeLine:
		//	{NewLineLine} NEWLINE
		@Override public ParserRule getRule() { return rule; }
		
		//{NewLineLine} NEWLINE
		public Group getGroup() { return cGroup; }
		
		//{NewLineLine}
		public Action getNewLineLineAction_0() { return cNewLineLineAction_0; }
		
		//NEWLINE
		public RuleCall getNEWLINETerminalRuleCall_1() { return cNEWLINETerminalRuleCall_1; }
	}
	public class CodeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.weiner.cpreprocess.CPreprocess.Code");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCodeAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCodeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCodeMYCODETerminalRuleCall_1_0 = (RuleCall)cCodeAssignment_1.eContents().get(0);
		private final RuleCall cNEWLINETerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Code SourceCodeLine:
		//	{Code} code=MYCODE
		//	NEWLINE
		@Override public ParserRule getRule() { return rule; }
		
		//{Code} code=MYCODE NEWLINE
		public Group getGroup() { return cGroup; }
		
		//{Code}
		public Action getCodeAction_0() { return cCodeAction_0; }
		
		//code=MYCODE
		public Assignment getCodeAssignment_1() { return cCodeAssignment_1; }
		
		//MYCODE
		public RuleCall getCodeMYCODETerminalRuleCall_1_0() { return cCodeMYCODETerminalRuleCall_1_0; }
		
		//NEWLINE
		public RuleCall getNEWLINETerminalRuleCall_2() { return cNEWLINETerminalRuleCall_2; }
	}
	
	
	private final ModelElements pModel;
	private final TranslationUnitElements pTranslationUnit;
	private final PreprocessorDirectivesElements pPreprocessorDirectives;
	private final IncludeDirectiveElements pIncludeDirective;
	private final NewLineLineElements pNewLineLine;
	private final CodeElements pCode;
	private final TerminalRule tHASH;
	private final TerminalRule tBACKSLASH;
	private final TerminalRule tWHITESPACE;
	private final TerminalRule tNEWLINE;
	private final TerminalRule tMYCODE;
	
	private final Grammar grammar;

	@Inject
	public CPreprocessGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pModel = new ModelElements();
		this.pTranslationUnit = new TranslationUnitElements();
		this.pPreprocessorDirectives = new PreprocessorDirectivesElements();
		this.pIncludeDirective = new IncludeDirectiveElements();
		this.pNewLineLine = new NewLineLineElements();
		this.pCode = new CodeElements();
		this.tHASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.weiner.cpreprocess.CPreprocess.HASH");
		this.tBACKSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.weiner.cpreprocess.CPreprocess.BACKSLASH");
		this.tWHITESPACE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.weiner.cpreprocess.CPreprocess.WHITESPACE");
		this.tNEWLINE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.weiner.cpreprocess.CPreprocess.NEWLINE");
		this.tMYCODE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.weiner.cpreprocess.CPreprocess.MYCODE");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("at.jku.weiner.cpreprocess.CPreprocess".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//Model:
	//	{Model} units+=TranslationUnit;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	//TranslationUnit:
	//	{TranslationUnit} (lines+=NewLineLine
	//	| lines+=Code)*;
	public TranslationUnitElements getTranslationUnitAccess() {
		return pTranslationUnit;
	}
	
	public ParserRule getTranslationUnitRule() {
		return getTranslationUnitAccess().getRule();
	}
	
	//PreprocessorDirectives SourceCodeLine:
	//	{PreprocessorDirectives} HASH
	//	directive=IncludeDirective
	//	NEWLINE
	public PreprocessorDirectivesElements getPreprocessorDirectivesAccess() {
		return pPreprocessorDirectives;
	}
	
	public ParserRule getPreprocessorDirectivesRule() {
		return getPreprocessorDirectivesAccess().getRule();
	}
	
	//IncludeDirective:
	//	{IncludeDirective}
	//	'include' string=NEWLINE;
	public IncludeDirectiveElements getIncludeDirectiveAccess() {
		return pIncludeDirective;
	}
	
	public ParserRule getIncludeDirectiveRule() {
		return getIncludeDirectiveAccess().getRule();
	}
	
	//NewLineLine SourceCodeLine:
	//	{NewLineLine} NEWLINE
	public NewLineLineElements getNewLineLineAccess() {
		return pNewLineLine;
	}
	
	public ParserRule getNewLineLineRule() {
		return getNewLineLineAccess().getRule();
	}
	
	//Code SourceCodeLine:
	//	{Code} code=MYCODE
	//	NEWLINE
	public CodeElements getCodeAccess() {
		return pCode;
	}
	
	public ParserRule getCodeRule() {
		return getCodeAccess().getRule();
	}
	
	//terminal HASH:
	//	'#';
	public TerminalRule getHASHRule() {
		return tHASH;
	}
	
	//terminal BACKSLASH:
	//	'\\';
	public TerminalRule getBACKSLASHRule() {
		return tBACKSLASH;
	}
	
	//terminal WHITESPACE:
	//	' ' | '\t' | BACKSLASH NEWLINE+;
	public TerminalRule getWHITESPACERule() {
		return tWHITESPACE;
	}
	
	//terminal NEWLINE:
	//	'\r' | '\n';
	public TerminalRule getNEWLINERule() {
		return tNEWLINE;
	}
	
	//terminal MYCODE:
	//	!(HASH | NEWLINE) !NEWLINE*;
	public TerminalRule getMYCODERule() {
		return tMYCODE;
	}
}
