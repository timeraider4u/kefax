/*
 * generated by Xtext 2.9.0-SNAPSHOT
 */
package at.jku.weiner.xtexttest.serializer;

import at.jku.weiner.xtexttest.services.XtextTestGrammarAccess;
import com.google.inject.Inject;
import java.util.List;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.IGrammarAccess;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.AbstractElementAlias;
import org.eclipse.xtext.serializer.analysis.ISyntacticSequencerPDAProvider.ISynTransition;
import org.eclipse.xtext.serializer.sequencer.AbstractSyntacticSequencer;

@SuppressWarnings("all")
public class XtextTestSyntacticSequencer extends AbstractSyntacticSequencer {

	protected XtextTestGrammarAccess grammarAccess;
	
	@Inject
	protected void init(IGrammarAccess access) {
		grammarAccess = (XtextTestGrammarAccess) access;
	}
	
	@Override
	protected String getUnassignedRuleCallToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if(ruleCall.getRule() == grammarAccess.getASSIGNASDATALISTRule())
			return getASSIGNASDATALISTToken(semanticObject, ruleCall, node);
		else if(ruleCall.getRule() == grammarAccess.getASSIGNASLISTRule())
			return getASSIGNASLISTToken(semanticObject, ruleCall, node);
		else if(ruleCall.getRule() == grammarAccess.getASSIGNASSINGLERule())
			return getASSIGNASSINGLEToken(semanticObject, ruleCall, node);
		else if(ruleCall.getRule() == grammarAccess.getASSIGNASSTRINGRule())
			return getASSIGNASSTRINGToken(semanticObject, ruleCall, node);
		else if(ruleCall.getRule() == grammarAccess.getCOMMARule())
			return getCOMMAToken(semanticObject, ruleCall, node);
		else if(ruleCall.getRule() == grammarAccess.getEXPECTEDRule())
			return getEXPECTEDToken(semanticObject, ruleCall, node);
		else if(ruleCall.getRule() == grammarAccess.getFILERule())
			return getFILEToken(semanticObject, ruleCall, node);
		else if(ruleCall.getRule() == grammarAccess.getISSAMEASINPUTFILERule())
			return getISSAMEASINPUTFILEToken(semanticObject, ruleCall, node);
		else if(ruleCall.getRule() == grammarAccess.getLANGUAGERule())
			return getLANGUAGEToken(semanticObject, ruleCall, node);
		else if(ruleCall.getRule() == grammarAccess.getLEFTPARENRule())
			return getLEFTPARENToken(semanticObject, ruleCall, node);
		else if(ruleCall.getRule() == grammarAccess.getLEXERRule())
			return getLEXERToken(semanticObject, ruleCall, node);
		else if(ruleCall.getRule() == grammarAccess.getOUTPUTRule())
			return getOUTPUTToken(semanticObject, ruleCall, node);
		else if(ruleCall.getRule() == grammarAccess.getPACKAGERule())
			return getPACKAGEToken(semanticObject, ruleCall, node);
		else if(ruleCall.getRule() == grammarAccess.getRIGHTPARENRule())
			return getRIGHTPARENToken(semanticObject, ruleCall, node);
		else if(ruleCall.getRule() == grammarAccess.getSOURCERule())
			return getSOURCEToken(semanticObject, ruleCall, node);
		else if(ruleCall.getRule() == grammarAccess.getSRCTEXTRule())
			return getSRCTEXTToken(semanticObject, ruleCall, node);
		return "";
	}
	
	/**
	 * terminal ASSIGNASDATALIST: '+*';
	 */
	protected String getASSIGNASDATALISTToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "+*";
	}
	
	/**
	 * terminal ASSIGNASLIST: '+=';
	 */
	protected String getASSIGNASLISTToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "+=";
	}
	
	/**
	 * terminal ASSIGNASSINGLE: '=';
	 */
	protected String getASSIGNASSINGLEToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "=";
	}
	
	/**
	 * terminal ASSIGNASSTRING: '++';
	 */
	protected String getASSIGNASSTRINGToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "++";
	}
	
	/**
	 * terminal COMMA: ',';
	 */
	protected String getCOMMAToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return ",";
	}
	
	/**
	 * terminal EXPECTED: 'expected';
	 */
	protected String getEXPECTEDToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "expected";
	}
	
	/**
	 * terminal FILE: 'file';
	 */
	protected String getFILEToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "file";
	}
	
	/**
	 * terminal ISSAMEASINPUTFILE: 'isSameAsInputFile';
	 */
	protected String getISSAMEASINPUTFILEToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "isSameAsInputFile";
	}
	
	/**
	 * terminal LANGUAGE: 'language';
	 */
	protected String getLANGUAGEToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "language";
	}
	
	/**
	 * terminal LEFTPAREN: '(';
	 */
	protected String getLEFTPARENToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "(";
	}
	
	/**
	 * terminal LEXER: 'lexer-tokens';
	 */
	protected String getLEXERToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "lexer-tokens";
	}
	
	/**
	 * terminal OUTPUT: 'output';
	 */
	protected String getOUTPUTToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "output";
	}
	
	/**
	 * terminal PACKAGE: 'package';
	 */
	protected String getPACKAGEToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "package";
	}
	
	/**
	 * terminal RIGHTPAREN: ')';
	 */
	protected String getRIGHTPARENToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return ")";
	}
	
	/**
	 * terminal SOURCE: 'source';
	 */
	protected String getSOURCEToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "source";
	}
	
	/**
	 * terminal SRCTEXT: 'text';
	 */
	protected String getSRCTEXTToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "text";
	}
	
	@Override
	protected void emitUnassignedTokens(EObject semanticObject, ISynTransition transition, INode fromNode, INode toNode) {
		if (transition.getAmbiguousSyntaxes().isEmpty()) return;
		List<INode> transitionNodes = collectNodes(fromNode, toNode);
		for (AbstractElementAlias syntax : transition.getAmbiguousSyntaxes()) {
			List<INode> syntaxNodes = getNodesFor(transitionNodes, syntax);
			acceptNodes(getLastNavigableState(), syntaxNodes);
		}
	}

}
