--- InternalC.g.original	2015-08-27 04:58:15.167523589 +0200
+++ InternalC.g.v1	2015-08-27 05:00:21.000000000 +0200
@@ -26,7 +26,6 @@
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-
 /*
  * generated by Xtext
  */
@@ -58,7 +57,9 @@
 import org.eclipse.xtext.parser.antlr.XtextTokenStream.HiddenTokens;
 import org.eclipse.xtext.parser.antlr.AntlrDatatypeRuleToken;
 import at.jku.isse.ecco.kefax.c.services.CGrammarAccess;
-
+import java.util.Set;
+import java.util.HashSet;
+import java.util.Stack;
 }
 
 @parser::members {
@@ -80,6 +81,75 @@
    	protected CGrammarAccess getGrammarAccess() {
    		return grammarAccess;
    	}
+   	
+   	private final class Symbols {
+		public final String scopeName;
+		public final Set<String> types = new HashSet<String>();
+		public Symbols(final String scopeName) {
+			this.scopeName = scopeName;
+		}
+	}
+	
+	protected final Stack<Symbols> scope = new Stack<Symbols>();
+	protected Symbols currScope = null;
+	
+	protected final boolean isTypeName(final String name) {
+		// System.out.println("searching for typeName='" + name + "', scopeSize='"
+		//	+ this.scope.size() + "'");
+		if (currScope.types.contains(name)) {
+			//System.out.println("found in currScope!");
+			return true;
+		}
+		for (int i = 0; i < this.scope.size(); i++) {
+			final Symbols symbols = this.scope.get(i);
+			if (symbols.types.contains(name)) {
+				// System.out.println("found in scope='" + symbols.scopeName + "'");
+				return true;
+			}
+			// System.out.println("no type found in scope='" + symbols.scopeName + "'");
+		}
+		return false;
+	}
+	
+	protected final void createNewScope(final String scopeName) {
+		// System.out.println("createNewScope='" + scopeName + "'");
+		final Symbols symbols = new Symbols(scopeName);
+		if (this.currScope != null) {
+			this.scope.push(this.currScope);
+		}
+		this.currScope = symbols;
+		this.setTypedef(false);
+	}
+	
+	protected final void removeScope() {
+		// System.out.println("removeScope='" + currScope.scopeName + "'");
+		if (this.scope.isEmpty()) {
+			this.currScope = null;
+		}
+		else {
+			this.currScope = this.scope.pop();
+		}
+		this.setTypedef(false);
+	}
+	
+	protected final void addTypedef(final String name) {
+		this.currScope.types.add(name);
+		// System.out.println("define type='" + name + "'");
+	}
+	
+	protected final void setTypedef(final boolean newTypeDef) {
+		isTypedefValue = newTypeDef;
+	}
+	
+	protected final boolean isTypedef() {
+		return isTypedefValue;
+	}
+	
+	protected boolean isTypedefValue = false;
+	
+	protected final boolean isIdentifier() {
+		return input.get(0).getType() == InternalCLexer.RULE_IDENTIFIER;
+	}
 }
 
 @rulecatch { 
@@ -152,9 +222,9 @@
 
 // Rule translationUnit
 ruletranslationUnit returns [EObject current=null] 
-    @init { enterRule(); 
+    @init { this.createNewScope("translationUnit"); enterRule(); 
     }
-    @after { leaveRule(); }:
+    @after { this.removeScope(); leaveRule(); }:
 (
 (
 		{ 
@@ -547,6 +617,7 @@
     }
 )(this_TYPEDEF_1=RULE_TYPEDEF
     { 
+    this.setTypedef(true); 
     newLeafNode(this_TYPEDEF_1, grammarAccess.getStorageClassSpecifierAccess().getTYPEDEFTerminalRuleCall_1_0()); 
     }
 
@@ -805,6 +876,11 @@
 (
 		lv_id_1_0=RULE_ID
 		{
+			if (this.isTypedef()) {
+						this.addTypedef(input.get(0).getText());
+			}
+		}
+		{
 			newLeafNode(lv_id_1_0, grammarAccess.getDirectDeclaratorAccess().getIdIDTerminalRuleCall_1_0_0()); 
 		}
 		{
@@ -867,6 +943,8 @@
     @init { enterRule(); 
     }
     @after { leaveRule(); }:
+    
+    {isTypeName(input.LT(1).getText())}?
 (
 (
 		lv_id_0_0=RULE_ID
