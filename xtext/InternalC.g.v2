/*
 [The "BSD licence"]
 Copyright (c) 2013 Sam Harwell
 Copyright (c) 2015 https://github.com/timeraider4u
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
 3. The name of the author may not be used to endorse or promote products
    derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*
 * generated by Xtext
 */
grammar InternalC;

options {
	superClass=AbstractInternalAntlrParser;
	
}

@lexer::header {
package at.jku.isse.ecco.kefax.c.parser.antlr.internal;

// Hack: Use our own Lexer superclass by means of import. 
// Currently there is no other way to specify the superclass for the lexer.
import org.eclipse.xtext.parser.antlr.Lexer;
}

@parser::header {
package at.jku.isse.ecco.kefax.c.parser.antlr.internal; 

import org.eclipse.xtext.*;
import org.eclipse.xtext.parser.*;
import org.eclipse.xtext.parser.impl.*;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser;
import org.eclipse.xtext.parser.antlr.XtextTokenStream;
import org.eclipse.xtext.parser.antlr.XtextTokenStream.HiddenTokens;
import org.eclipse.xtext.parser.antlr.AntlrDatatypeRuleToken;
import at.jku.isse.ecco.kefax.c.services.CGrammarAccess;
import java.util.Set;
import java.util.HashSet;
import java.util.Stack;
}

@parser::members {

 	private CGrammarAccess grammarAccess;
 	
    public InternalCParser(TokenStream input, CGrammarAccess grammarAccess) {
        this(input);
        this.grammarAccess = grammarAccess;
        registerRules(grammarAccess.getGrammar());
    }
    
    @Override
    protected String getFirstRuleName() {
    	return "Model";	
   	}
   	
   	@Override
   	protected CGrammarAccess getGrammarAccess() {
   		return grammarAccess;
   	}
   	
   	private final class Symbols {
		public final String scopeName;
		public final Set<String> types = new HashSet<String>();
		public Symbols(final String scopeName) {
			this.scopeName = scopeName;
		}
	}
	
	protected final Stack<Symbols> scope = new Stack<Symbols>();
	protected Symbols currScope = null;
	
	protected final boolean isTypeName(final String name) {
		// System.out.println("searching for typeName='" + name + "', scopeSize='"
		//	+ this.scope.size() + "'");
		if (currScope.types.contains(name)) {
			//System.out.println("found in currScope!");
			return true;
		}
		for (int i = 0; i < this.scope.size(); i++) {
			final Symbols symbols = this.scope.get(i);
			if (symbols.types.contains(name)) {
				// System.out.println("found in scope='" + symbols.scopeName + "'");
				return true;
			}
			// System.out.println("no type found in scope='" + symbols.scopeName + "'");
		}
		return false;
	}
	
	protected final void createNewScope(final String scopeName) {
		// System.out.println("createNewScope='" + scopeName + "'");
		final Symbols symbols = new Symbols(scopeName);
		if (this.currScope != null) {
			this.scope.push(this.currScope);
		}
		this.currScope = symbols;
		this.setTypedef(false);
	}
	
	protected final void removeScope() {
		// System.out.println("removeScope='" + currScope.scopeName + "'");
		if (this.scope.isEmpty()) {
			this.currScope = null;
		}
		else {
			this.currScope = this.scope.pop();
		}
		this.setTypedef(false);
	}
	
	protected final void addTypedef(final String name) {
		this.currScope.types.add(name);
		// System.out.println("define type='" + name + "'");
	}
	
	protected final void setTypedef(final boolean newTypeDef) {
		isTypedefValue = newTypeDef;
	}
	
	protected final boolean isTypedef() {
		return isTypedefValue;
	}
	
	protected boolean isTypedefValue = false;
	
	protected final boolean isIdentifier() {
		return input.get(0).getType() == InternalCLexer.RULE_IDENTIFIER;
	}
}

@rulecatch { 
    catch (RecognitionException re) { 
        recover(input,re); 
        appendSkippedTokens();
    } 
}




// Entry rule entryRuleModel
entryRuleModel returns [EObject current=null] 
	:
	{ newCompositeNode(grammarAccess.getModelRule()); }
	 iv_ruleModel=ruleModel 
	 { $current=$iv_ruleModel.current; } 
	 EOF 
;

// Rule Model
ruleModel returns [EObject current=null] 
    @init { enterRule(); 
    }
    @after { leaveRule(); }:
((
    {
        $current = forceCreateModelElement(
            grammarAccess.getModelAccess().getModelAction_0(),
            $current);
    }
)(
(
		{ 
	        newCompositeNode(grammarAccess.getModelAccess().getUnitTranslationUnitParserRuleCall_1_0()); 
	    }
		lv_unit_1_0=ruletranslationUnit		{
	        if ($current==null) {
	            $current = createModelElementForParent(grammarAccess.getModelRule());
	        }
       		add(
       			$current, 
       			"unit",
        		lv_unit_1_0, 
        		"translationUnit");
	        afterParserOrEnumRuleCall();
	    }

)
)?(this_EOF_TERMINAL_2=RULE_EOF_TERMINAL
    { 
    newLeafNode(this_EOF_TERMINAL_2, grammarAccess.getModelAccess().getEOF_TERMINALTerminalRuleCall_2()); 
    }
)?)
;





// Entry rule entryRuletranslationUnit
entryRuletranslationUnit returns [EObject current=null] 
	:
	{ newCompositeNode(grammarAccess.getTranslationUnitRule()); }
	 iv_ruletranslationUnit=ruletranslationUnit 
	 { $current=$iv_ruletranslationUnit.current; } 
	 EOF 
;

// Rule translationUnit
ruletranslationUnit returns [EObject current=null] 
    @init { this.createNewScope("translationUnit"); enterRule(); 
    }
    @after { this.removeScope(); leaveRule(); }:
(
(
		{ 
	        newCompositeNode(grammarAccess.getTranslationUnitAccess().getExternalExternalDeclarationParserRuleCall_0()); 
	    }
		lv_external_0_0=ruleexternalDeclaration		{
	        if ($current==null) {
	            $current = createModelElementForParent(grammarAccess.getTranslationUnitRule());
	        }
       		add(
       			$current, 
       			"external",
        		lv_external_0_0, 
        		"externalDeclaration");
	        afterParserOrEnumRuleCall();
	    }

)
)+
;





// Entry rule entryRuleexternalDeclaration
entryRuleexternalDeclaration returns [EObject current=null] 
	:
	{ newCompositeNode(grammarAccess.getExternalDeclarationRule()); }
	 iv_ruleexternalDeclaration=ruleexternalDeclaration 
	 { $current=$iv_ruleexternalDeclaration.current; } 
	 EOF 
;

// Rule externalDeclaration
ruleexternalDeclaration returns [EObject current=null] 
    @init { enterRule(); 
    }
    @after { leaveRule(); }:
(((
    {
        $current = forceCreateModelElement(
            grammarAccess.getExternalDeclarationAccess().getExternalDeclarationAction_0_0(),
            $current);
    }
)(
(
		{ 
	        newCompositeNode(grammarAccess.getExternalDeclarationAccess().getDeclarationDeclarationParserRuleCall_0_1_0()); 
	    }
		lv_declaration_1_0=ruledeclaration		{
	        if ($current==null) {
	            $current = createModelElementForParent(grammarAccess.getExternalDeclarationRule());
	        }
       		set(
       			$current, 
       			"declaration",
        		lv_declaration_1_0, 
        		"declaration");
	        afterParserOrEnumRuleCall();
	    }

)
))
    |((
    {
        $current = forceCreateModelElement(
            grammarAccess.getExternalDeclarationAccess().getExternalDeclarationAction_1_0(),
            $current);
    }
)this_SEMI_3=RULE_SEMI
    { 
    newLeafNode(this_SEMI_3, grammarAccess.getExternalDeclarationAccess().getSEMITerminalRuleCall_1_1()); 
    }
))
;





// Entry rule entryRuledeclaration
entryRuledeclaration returns [EObject current=null] 
	:
	{ newCompositeNode(grammarAccess.getDeclarationRule()); }
	 iv_ruledeclaration=ruledeclaration 
	 { $current=$iv_ruledeclaration.current; } 
	 EOF 
;

// Rule declaration
ruledeclaration returns [EObject current=null] 
    @init { enterRule(); 
    }
    @after { leaveRule(); }:
((
(
		{ 
	        newCompositeNode(grammarAccess.getDeclarationAccess().getSpecifiersDeclarationSpecifiersParserRuleCall_0_0()); 
	    }
		lv_specifiers_0_0=ruledeclarationSpecifiers		{
	        if ($current==null) {
	            $current = createModelElementForParent(grammarAccess.getDeclarationRule());
	        }
       		set(
       			$current, 
       			"specifiers",
        		lv_specifiers_0_0, 
        		"declarationSpecifiers");
	        afterParserOrEnumRuleCall();
	    }

)
)(
(
		{ 
	        newCompositeNode(grammarAccess.getDeclarationAccess().getInitDeclaratorListInitDeclaratorListParserRuleCall_1_0()); 
	    }
		lv_initDeclaratorList_1_0=ruleinitDeclaratorList		{
	        if ($current==null) {
	            $current = createModelElementForParent(grammarAccess.getDeclarationRule());
	        }
       		add(
       			$current, 
       			"initDeclaratorList",
        		lv_initDeclaratorList_1_0, 
        		"initDeclaratorList");
	        afterParserOrEnumRuleCall();
	    }

)
)?this_SEMI_2=RULE_SEMI
    { 
    newLeafNode(this_SEMI_2, grammarAccess.getDeclarationAccess().getSEMITerminalRuleCall_2()); 
    }
)
;





// Entry rule entryRuledeclarationSpecifiers
entryRuledeclarationSpecifiers returns [EObject current=null] 
	:
	{ newCompositeNode(grammarAccess.getDeclarationSpecifiersRule()); }
	 iv_ruledeclarationSpecifiers=ruledeclarationSpecifiers 
	 { $current=$iv_ruledeclarationSpecifiers.current; } 
	 EOF 
;

// Rule declarationSpecifiers
ruledeclarationSpecifiers returns [EObject current=null] 
    @init { enterRule(); 
    }
    @after { leaveRule(); }:
((
    /*{
        $current = forceCreateModelElement(
            grammarAccess.getDeclarationSpecifiersAccess().getDeclarationSpecifiersAction_0(),
            $current);
    }*/
)(
(
		/*{ 
	        newCompositeNode(grammarAccess.getDeclarationSpecifiersAccess().getSpecifiersDeclarationSpecifierParserRuleCall_1_0()); 
	    }*/
		lv_specifiers_1_0=ruledeclarationSpecifier		{
	        if ($current==null) {
	            $current = createModelElementForParent(grammarAccess.getDeclarationSpecifiersRule());
	        }
       		add(
       			$current, 
       			"specifiers",
        		lv_specifiers_1_0, 
        		"declarationSpecifier");
	        afterParserOrEnumRuleCall();
	    }

)
)+)
;





// Entry rule entryRuledeclarationSpecifier
entryRuledeclarationSpecifier returns [EObject current=null] 
	:
	{ newCompositeNode(grammarAccess.getDeclarationSpecifierRule()); }
	 iv_ruledeclarationSpecifier=ruledeclarationSpecifier 
	 { $current=$iv_ruledeclarationSpecifier.current; } 
	 EOF 
;

// Rule declarationSpecifier
ruledeclarationSpecifier returns [EObject current=null] 
    @init { enterRule(); 
    }
    @after { leaveRule(); }:
((
    /*{
        $current = forceCreateModelElement(
            grammarAccess.getDeclarationSpecifierAccess().getDeclarationSpecifierAction_0(),
            $current);
    }*/
)((
(
		{ 
	        newCompositeNode(grammarAccess.getDeclarationSpecifierAccess().getDeclarationSpecifierStorageClassSpecifierParserRuleCall_1_0_0()); 
	    }
		lv_declarationSpecifier_1_0=rulestorageClassSpecifier		{
	        if ($current==null) {
	            $current = createModelElementForParent(grammarAccess.getDeclarationSpecifierRule());
	        }
       		add(
       			$current, 
       			"declarationSpecifier",
        		lv_declarationSpecifier_1_0, 
        		"storageClassSpecifier");
	        afterParserOrEnumRuleCall();
	    }

)
)
    |(
(
		/*{ 
	        newCompositeNode(grammarAccess.getDeclarationSpecifierAccess().getDeclarationSpecifierTypeSpecifierParserRuleCall_1_1_0()); 
	    }*/
		lv_declarationSpecifier_2_0=ruletypeSpecifier		{
	        if ($current==null) {
	            $current = createModelElementForParent(grammarAccess.getDeclarationSpecifierRule());
	        }
       		add(
       			$current, 
       			"declarationSpecifier",
        		lv_declarationSpecifier_2_0, 
        		"typeSpecifier");
	        afterParserOrEnumRuleCall();
	    }

)
)
    |(
(
		{ 
	        newCompositeNode(grammarAccess.getDeclarationSpecifierAccess().getDeclarationSpecifierTypeQualifierParserRuleCall_1_2_0()); 
	    }
		lv_declarationSpecifier_3_0=ruletypeQualifier		{
	        if ($current==null) {
	            $current = createModelElementForParent(grammarAccess.getDeclarationSpecifierRule());
	        }
       		add(
       			$current, 
       			"declarationSpecifier",
        		lv_declarationSpecifier_3_0, 
        		"typeQualifier");
	        afterParserOrEnumRuleCall();
	    }

)
)))
;





// Entry rule entryRuleinitDeclaratorList
entryRuleinitDeclaratorList returns [EObject current=null] 
	:
	{ newCompositeNode(grammarAccess.getInitDeclaratorListRule()); }
	 iv_ruleinitDeclaratorList=ruleinitDeclaratorList 
	 { $current=$iv_ruleinitDeclaratorList.current; } 
	 EOF 
;

// Rule initDeclaratorList
ruleinitDeclaratorList returns [EObject current=null] 
    @init { enterRule(); 
    }
    @after { leaveRule(); }:
((
(
		{ 
	        newCompositeNode(grammarAccess.getInitDeclaratorListAccess().getInitDeclaratorInitDeclaratorParserRuleCall_0_0()); 
	    }
		lv_initDeclarator_0_0=ruleinitDeclarator		{
	        if ($current==null) {
	            $current = createModelElementForParent(grammarAccess.getInitDeclaratorListRule());
	        }
       		set(
       			$current, 
       			"initDeclarator",
        		lv_initDeclarator_0_0, 
        		"initDeclarator");
	        afterParserOrEnumRuleCall();
	    }

)
)(this_COMMA_1=RULE_COMMA
    { 
    newLeafNode(this_COMMA_1, grammarAccess.getInitDeclaratorListAccess().getCOMMATerminalRuleCall_1_0()); 
    }
(
(
		{ 
	        newCompositeNode(grammarAccess.getInitDeclaratorListAccess().getInitDeclarator2InitDeclaratorParserRuleCall_1_1_0()); 
	    }
		lv_initDeclarator2_2_0=ruleinitDeclarator		{
	        if ($current==null) {
	            $current = createModelElementForParent(grammarAccess.getInitDeclaratorListRule());
	        }
       		add(
       			$current, 
       			"initDeclarator2",
        		lv_initDeclarator2_2_0, 
        		"initDeclarator");
	        afterParserOrEnumRuleCall();
	    }

)
))*)
;





// Entry rule entryRuleinitDeclarator
entryRuleinitDeclarator returns [EObject current=null] 
	:
	{ newCompositeNode(grammarAccess.getInitDeclaratorRule()); }
	 iv_ruleinitDeclarator=ruleinitDeclarator 
	 { $current=$iv_ruleinitDeclarator.current; } 
	 EOF 
;

// Rule initDeclarator
ruleinitDeclarator returns [EObject current=null] 
    @init { enterRule(); 
    }
    @after { leaveRule(); }:
(
(
		{ 
	        newCompositeNode(grammarAccess.getInitDeclaratorAccess().getDeclaratorDeclaratorParserRuleCall_0()); 
	    }
		lv_declarator_0_0=ruledeclarator		{
	        if ($current==null) {
	            $current = createModelElementForParent(grammarAccess.getInitDeclaratorRule());
	        }
       		set(
       			$current, 
       			"declarator",
        		lv_declarator_0_0, 
        		"declarator");
	        afterParserOrEnumRuleCall();
	    }

)
)
;





// Entry rule entryRulestorageClassSpecifier
entryRulestorageClassSpecifier returns [EObject current=null] 
	:
	{ newCompositeNode(grammarAccess.getStorageClassSpecifierRule()); }
	 iv_rulestorageClassSpecifier=rulestorageClassSpecifier 
	 { $current=$iv_rulestorageClassSpecifier.current; } 
	 EOF 
;

// Rule storageClassSpecifier
rulestorageClassSpecifier returns [EObject current=null] 
    @init { enterRule(); 
    }
    @after { leaveRule(); }:
((
    {
        $current = forceCreateModelElement(
            grammarAccess.getStorageClassSpecifierAccess().getStorageClassSpecifierAction_0(),
            $current);
    }
)(this_TYPEDEF_1=RULE_TYPEDEF
    { 
    this.setTypedef(true); 
    newLeafNode(this_TYPEDEF_1, grammarAccess.getStorageClassSpecifierAccess().getTYPEDEFTerminalRuleCall_1_0()); 
    }

    |this_EXTERN_2=RULE_EXTERN
    { 
    newLeafNode(this_EXTERN_2, grammarAccess.getStorageClassSpecifierAccess().getEXTERNTerminalRuleCall_1_1()); 
    }

    |this_STATIC_3=RULE_STATIC
    { 
    newLeafNode(this_STATIC_3, grammarAccess.getStorageClassSpecifierAccess().getSTATICTerminalRuleCall_1_2()); 
    }

    |this_THREADLOCAL_4=RULE_THREADLOCAL
    { 
    newLeafNode(this_THREADLOCAL_4, grammarAccess.getStorageClassSpecifierAccess().getTHREADLOCALTerminalRuleCall_1_3()); 
    }

    |this_AUTO_5=RULE_AUTO
    { 
    newLeafNode(this_AUTO_5, grammarAccess.getStorageClassSpecifierAccess().getAUTOTerminalRuleCall_1_4()); 
    }

    |this_REGISTER_6=RULE_REGISTER
    { 
    newLeafNode(this_REGISTER_6, grammarAccess.getStorageClassSpecifierAccess().getREGISTERTerminalRuleCall_1_5()); 
    }
))
;





// Entry rule entryRuletypeSpecifier
entryRuletypeSpecifier returns [EObject current=null] 
	:
	{ newCompositeNode(grammarAccess.getTypeSpecifierRule()); }
	 iv_ruletypeSpecifier=ruletypeSpecifier 
	 { $current=$iv_ruletypeSpecifier.current; } 
	 EOF 
;

// Rule typeSpecifier
ruletypeSpecifier returns [EObject current=null] 
    @init { enterRule(); 
    }
    @after { leaveRule(); }:
((
    /*{
        $current = forceCreateModelElement(
            grammarAccess.getTypeSpecifierAccess().getTypeSpecifierAction_0(),
            $current);
    }*/
)(this_VOID_1=RULE_VOID
    { 
    newLeafNode(this_VOID_1, grammarAccess.getTypeSpecifierAccess().getVOIDTerminalRuleCall_1_0()); 
    }

    |this_CHAR_2=RULE_CHAR
    { 
    newLeafNode(this_CHAR_2, grammarAccess.getTypeSpecifierAccess().getCHARTerminalRuleCall_1_1()); 
    }

    |this_SHORT_3=RULE_SHORT
    { 
    newLeafNode(this_SHORT_3, grammarAccess.getTypeSpecifierAccess().getSHORTTerminalRuleCall_1_2()); 
    }

    |this_INT_4=RULE_INT
    { 
    newLeafNode(this_INT_4, grammarAccess.getTypeSpecifierAccess().getINTTerminalRuleCall_1_3()); 
    }

    |this_LONG_5=RULE_LONG
    { 
    newLeafNode(this_LONG_5, grammarAccess.getTypeSpecifierAccess().getLONGTerminalRuleCall_1_4()); 
    }

    |this_FLOAT_6=RULE_FLOAT
    { 
    newLeafNode(this_FLOAT_6, grammarAccess.getTypeSpecifierAccess().getFLOATTerminalRuleCall_1_5()); 
    }

    |this_DOUBLE_7=RULE_DOUBLE
    { 
    newLeafNode(this_DOUBLE_7, grammarAccess.getTypeSpecifierAccess().getDOUBLETerminalRuleCall_1_6()); 
    }

    |this_SIGNED_8=RULE_SIGNED
    { 
    newLeafNode(this_SIGNED_8, grammarAccess.getTypeSpecifierAccess().getSIGNEDTerminalRuleCall_1_7()); 
    }

    |this_UNSIGNED_9=RULE_UNSIGNED
    { 
    newLeafNode(this_UNSIGNED_9, grammarAccess.getTypeSpecifierAccess().getUNSIGNEDTerminalRuleCall_1_8()); 
    }

    |this_BOOL_10=RULE_BOOL
    { 
    newLeafNode(this_BOOL_10, grammarAccess.getTypeSpecifierAccess().getBOOLTerminalRuleCall_1_9()); 
    }

    |this_COMPLEX_11=RULE_COMPLEX
    { 
    newLeafNode(this_COMPLEX_11, grammarAccess.getTypeSpecifierAccess().getCOMPLEXTerminalRuleCall_1_10()); 
    }

    |	otherlv_12='__m128' 
    {
    	newLeafNode(otherlv_12, grammarAccess.getTypeSpecifierAccess().get__m128Keyword_1_11());
    }

    |	otherlv_13='__m128d' 
    {
    	newLeafNode(otherlv_13, grammarAccess.getTypeSpecifierAccess().get__m128dKeyword_1_12());
    }

    |	otherlv_14='__m128i' 
    {
    	newLeafNode(otherlv_14, grammarAccess.getTypeSpecifierAccess().get__m128iKeyword_1_13());
    }

    |(
(
		/*{ 
	        newCompositeNode(grammarAccess.getTypeSpecifierAccess().getNameTypedefNameParserRuleCall_1_14_0()); 
	    }*/
		lv_name_15_0=ruletypedefName		{
	        if ($current==null) {
	            $current = createModelElementForParent(grammarAccess.getTypeSpecifierRule());
	        }
       		set(
       			$current, 
       			"name",
        		lv_name_15_0, 
        		"typedefName");
	        afterParserOrEnumRuleCall();
	    }

)
)))
;





// Entry rule entryRuletypeQualifier
entryRuletypeQualifier returns [EObject current=null] 
	:
	{ newCompositeNode(grammarAccess.getTypeQualifierRule()); }
	 iv_ruletypeQualifier=ruletypeQualifier 
	 { $current=$iv_ruletypeQualifier.current; } 
	 EOF 
;

// Rule typeQualifier
ruletypeQualifier returns [EObject current=null] 
    @init { enterRule(); 
    }
    @after { leaveRule(); }:
((
    {
        $current = forceCreateModelElement(
            grammarAccess.getTypeQualifierAccess().getTypeQualifierAction_0(),
            $current);
    }
)(this_CONST_1=RULE_CONST
    { 
    newLeafNode(this_CONST_1, grammarAccess.getTypeQualifierAccess().getCONSTTerminalRuleCall_1_0()); 
    }

    |this_RESTRICT_2=RULE_RESTRICT
    { 
    newLeafNode(this_RESTRICT_2, grammarAccess.getTypeQualifierAccess().getRESTRICTTerminalRuleCall_1_1()); 
    }

    |this_VOLATILE_3=RULE_VOLATILE
    { 
    newLeafNode(this_VOLATILE_3, grammarAccess.getTypeQualifierAccess().getVOLATILETerminalRuleCall_1_2()); 
    }

    |this_ATOMIC_4=RULE_ATOMIC
    { 
    newLeafNode(this_ATOMIC_4, grammarAccess.getTypeQualifierAccess().getATOMICTerminalRuleCall_1_3()); 
    }
))
;





// Entry rule entryRuledeclarator
entryRuledeclarator returns [EObject current=null] 
	:
	{ newCompositeNode(grammarAccess.getDeclaratorRule()); }
	 iv_ruledeclarator=ruledeclarator 
	 { $current=$iv_ruledeclarator.current; } 
	 EOF 
;

// Rule declarator
ruledeclarator returns [EObject current=null] 
    @init { enterRule(); 
    }
    @after { leaveRule(); }:
(
(
		{ 
	        newCompositeNode(grammarAccess.getDeclaratorAccess().getDeclaratorDirectDeclaratorParserRuleCall_0()); 
	    }
		lv_declarator_0_0=ruledirectDeclarator		{
	        if ($current==null) {
	            $current = createModelElementForParent(grammarAccess.getDeclaratorRule());
	        }
       		set(
       			$current, 
       			"declarator",
        		lv_declarator_0_0, 
        		"directDeclarator");
	        afterParserOrEnumRuleCall();
	    }

)
)
;





// Entry rule entryRuledirectDeclarator
entryRuledirectDeclarator returns [EObject current=null] 
	:
	{ newCompositeNode(grammarAccess.getDirectDeclaratorRule()); }
	 iv_ruledirectDeclarator=ruledirectDeclarator 
	 { $current=$iv_ruledirectDeclarator.current; } 
	 EOF 
;

// Rule directDeclarator
ruledirectDeclarator returns [EObject current=null] 
    @init { enterRule(); 
    }
    @after { leaveRule(); }:
((
    {
        $current = forceCreateModelElement(
            grammarAccess.getDirectDeclaratorAccess().getDirectDeclaratorAction_0(),
            $current);
    }
)((
(
		lv_id_1_0=RULE_ID
		{
			if (this.isTypedef()) {
						this.addTypedef(input.get(0).getText());
			}
		}
		{
			newLeafNode(lv_id_1_0, grammarAccess.getDirectDeclaratorAccess().getIdIDTerminalRuleCall_1_0_0()); 
		}
		{
	        if ($current==null) {
	            $current = createModelElement(grammarAccess.getDirectDeclaratorRule());
	        }
       		setWithLastConsumed(
       			$current, 
       			"id",
        		lv_id_1_0, 
        		"ID");
	    }

)
)
    |(this_LEFTPAREN_2=RULE_LEFTPAREN
    { 
    newLeafNode(this_LEFTPAREN_2, grammarAccess.getDirectDeclaratorAccess().getLEFTPARENTerminalRuleCall_1_1_0()); 
    }
(
(
		{ 
	        newCompositeNode(grammarAccess.getDirectDeclaratorAccess().getDeclaratorDeclaratorParserRuleCall_1_1_1_0()); 
	    }
		lv_declarator_3_0=ruledeclarator		{
	        if ($current==null) {
	            $current = createModelElementForParent(grammarAccess.getDirectDeclaratorRule());
	        }
       		set(
       			$current, 
       			"declarator",
        		lv_declarator_3_0, 
        		"declarator");
	        afterParserOrEnumRuleCall();
	    }

)
)this_RIGHTPAREN_4=RULE_RIGHTPAREN
    { 
    newLeafNode(this_RIGHTPAREN_4, grammarAccess.getDirectDeclaratorAccess().getRIGHTPARENTerminalRuleCall_1_1_2()); 
    }
)))
;





// Entry rule entryRuletypedefName
entryRuletypedefName returns [EObject current=null] 
	:
	{ newCompositeNode(grammarAccess.getTypedefNameRule()); }
	 iv_ruletypedefName=ruletypedefName 
	 { $current=$iv_ruletypedefName.current; } 
	 EOF 
;

// Rule typedefName
ruletypedefName returns [EObject current=null] 
    @init { enterRule(); 
    }
    @after { leaveRule(); }:
    
    {isTypeName(input.LT(1).getText())}?
(
(
		lv_id_0_0=RULE_ID
		{
			newLeafNode(lv_id_0_0, grammarAccess.getTypedefNameAccess().getIdIDTerminalRuleCall_0()); 
		}
		{
	        if ($current==null) {
	            $current = createModelElement(grammarAccess.getTypedefNameRule());
	        }
       		setWithLastConsumed(
       			$current, 
       			"id",
        		lv_id_0_0, 
        		"ID");
	    }

)
)
;





RULE_UNDERSCORE : '_';

RULE_AUTO : 'auto';

RULE_BREAK : 'break';

RULE_CASE : 'case';

RULE_CHAR : 'char';

RULE_CONST : 'const';

RULE_CONTINUE : 'continue';

RULE_DEFAULT : 'default';

RULE_DO : 'do';

RULE_DOUBLE : 'double';

RULE_ELSE : 'else';

RULE_ENUM : 'enum';

RULE_EXTERN : 'extern';

RULE_FLOAT : 'float';

RULE_FOR : 'for';

RULE_GOTO : 'goto';

RULE_IF : 'if';

RULE_INLINE : 'inline';

RULE_INT : 'int';

RULE_LONG : 'long';

RULE_REGISTER : 'register';

RULE_RESTRICT : 'restrict';

RULE_RETURN : 'return';

RULE_SHORT : 'short';

RULE_SIGNED : 'signed';

RULE_SIZEOF : 'sizeof';

RULE_STATIC : 'static';

RULE_STRUCT : 'struct';

RULE_SWITCH : 'switch';

RULE_TYPEDEF : 'typedef';

RULE_UNION : 'union';

RULE_UNSIGNED : 'unsigned';

RULE_VOID : 'void';

RULE_VOLATILE : 'volatile';

RULE_WHILE : 'while';

RULE_ALIGNAS : '_Alignas';

RULE_ALIGNOF : '_Alignof';

RULE_ASM : 'asm';

RULE_ATOMIC : '_Atomic';

RULE_BOOL : '_Bool';

RULE_COMPLEX : '_Complex';

RULE_GENERIC : '_Generic';

RULE_IMAGINARY : '_Imaginary';

RULE_NORETURN : '_Noreturn';

RULE_STATICASSERT : '_Static_assert';

RULE_THREADLOCAL : '_Thread_local';

RULE_PRAGMA : 'pragma';

RULE_LEFTPAREN : '(';

RULE_RIGHTPAREN : ')';

RULE_LEFTBRACKET : '[';

RULE_RIGHTBRACKET : ']';

RULE_LEFTBRACE : '{';

RULE_RIGHTBRACE : '}';

RULE_LESS : '<';

RULE_LESSEQUAL : RULE_LESS RULE_ASSIGN;

RULE_GREATER : '>';

RULE_GREATEREQUAL : RULE_GREATER RULE_ASSIGN;

RULE_LEFTSHIFT : RULE_LESS RULE_LESS;

RULE_RIGHTSHIFT : RULE_GREATER RULE_GREATER;

RULE_PLUS : '+';

RULE_PLUSPLUS : RULE_PLUS RULE_PLUS;

RULE_MINUS : '-';

RULE_MINUSMINUS : RULE_MINUS RULE_MINUS;

RULE_STAR : '*';

RULE_DIV : '/';

RULE_MOD : '%';

RULE_AND : '&';

RULE_ANDAND : RULE_AND RULE_AND;

RULE_OR : '|';

RULE_OROR : RULE_OR RULE_OR;

RULE_CARET : '^';

RULE_NOT : '!';

RULE_TILDE : '~';

RULE_QUESTION : '?';

RULE_COLON : ':';

RULE_SEMI : ';';

RULE_COMMA : ',';

RULE_ASSIGN : '=';

RULE_STARASSIGN : RULE_STAR RULE_ASSIGN;

RULE_DIVASSIGN : RULE_DIV RULE_ASSIGN;

RULE_MODASSIGN : RULE_MOD RULE_ASSIGN;

RULE_PLUSASSIGN : RULE_PLUS RULE_ASSIGN;

RULE_MINUSASSIGN : RULE_MINUS RULE_ASSIGN;

RULE_LEFTSHIFTASSIGN : RULE_LEFTSHIFT RULE_ASSIGN;

RULE_RIGHTSHIFTASSIGN : RULE_RIGHTSHIFT RULE_ASSIGN;

RULE_ANDASSIGN : RULE_AND RULE_ASSIGN;

RULE_XORASSIGN : RULE_CARET RULE_ASSIGN;

RULE_ORASSIGN : RULE_OR RULE_ASSIGN;

RULE_EQUAL : RULE_ASSIGN RULE_ASSIGN;

RULE_NOTEQUAL : RULE_NOT RULE_ASSIGN;

RULE_ARROW : RULE_MINUS RULE_GREATER;

RULE_DOT : '.';

RULE_ELLIPSIS : RULE_DOT RULE_DOT RULE_DOT;

RULE_ZERO : '0';

fragment RULE_IDENTIFIER : RULE_IDENTIFIERNONDIGIT (RULE_IDENTIFIERNONDIGIT|RULE_DIGIT)*;

fragment RULE_IDENTIFIERNONDIGIT : (RULE_NONDIGIT|RULE_UNIVERSALCHARACTERNAME);

fragment RULE_NONDIGIT : ('a'..'z'|'A'..'Z');

fragment RULE_DIGIT : '0'..'9';

fragment RULE_UNIVERSALCHARACTERNAME : ('\\u' RULE_HEXQUAD|'\\U' RULE_HEXQUAD RULE_HEXQUAD);

fragment RULE_HEXQUAD : RULE_HEXADECIMALDIGIT RULE_HEXADECIMALDIGIT RULE_HEXADECIMALDIGIT RULE_HEXADECIMALDIGIT;

RULE_CONSTANT : (RULE_INTEGERCONSTANT|RULE_FLOATINGCONSTANT|RULE_CHARACTERCONSTANT);

fragment RULE_INTEGERCONSTANT : (RULE_DECIMALCONSTANT RULE_INTEGERSUFFIX?|RULE_OCTALCONSTANT RULE_INTEGERSUFFIX?|RULE_HEXADECIMALCONSTANT RULE_INTEGERSUFFIX?);

fragment RULE_DECIMALCONSTANT : RULE_NONZERODIGIT RULE_DIGIT*;

fragment RULE_OCTALCONSTANT : '0' RULE_OCTALDIGIT*;

fragment RULE_HEXADECIMALCONSTANT : RULE_HEXADECIMALPREFIX RULE_HEXADECIMALDIGIT+;

fragment RULE_HEXADECIMALPREFIX : '0' ('x'|'X');

fragment RULE_NONZERODIGIT : '1'..'9';

fragment RULE_OCTALDIGIT : '0'..'7';

fragment RULE_HEXADECIMALDIGIT : ('0'..'9'|'a'..'f'|'A'..'F');

fragment RULE_INTEGERSUFFIX : (RULE_UNSIGNEDSUFFIX RULE_LONGSUFFIX?|RULE_UNSIGNEDSUFFIX RULE_LONGLONGSUFFIX|RULE_LONGSUFFIX RULE_UNSIGNEDSUFFIX?|RULE_LONGLONGSUFFIX RULE_UNSIGNEDSUFFIX?);

fragment RULE_UNSIGNEDSUFFIX : ('u'|'U');

fragment RULE_LONGSUFFIX : ('l'|'L');

fragment RULE_LONGLONGSUFFIX : ('ll'|'LL');

fragment RULE_FLOATINGCONSTANT : (RULE_DECIMALFLOATINGCONSTANT|RULE_HEXADECIMALFLOATINGCONSTANT);

fragment RULE_DECIMALFLOATINGCONSTANT : (RULE_FRACTIONALCONSTANT RULE_EXPONENTPART? RULE_FLOATINGSUFFIX?|RULE_DIGITSEQUENCE RULE_EXPONENTPART RULE_FLOATINGSUFFIX?);

fragment RULE_HEXADECIMALFLOATINGCONSTANT : (RULE_HEXADECIMALPREFIX RULE_HEXADECIMALFRACTIONALCONSTANT RULE_BINARYEXPONENTPART RULE_FLOATINGSUFFIX?|RULE_HEXADECIMALPREFIX RULE_HEXADECIMALDIGITSEQUENCE RULE_BINARYEXPONENTPART RULE_FLOATINGSUFFIX?);

fragment RULE_FRACTIONALCONSTANT : (RULE_DIGITSEQUENCE? RULE_DOT RULE_DIGITSEQUENCE|RULE_DIGITSEQUENCE RULE_DOT);

fragment RULE_EXPONENTPART : ('e' RULE_SIGN? RULE_DIGITSEQUENCE|'E' RULE_SIGN? RULE_DIGITSEQUENCE);

fragment RULE_SIGN : (RULE_PLUS|RULE_MINUS);

fragment RULE_DIGITSEQUENCE : RULE_DIGIT+;

fragment RULE_HEXADECIMALFRACTIONALCONSTANT : (RULE_HEXADECIMALDIGITSEQUENCE? RULE_DOT RULE_HEXADECIMALDIGITSEQUENCE|RULE_HEXADECIMALDIGITSEQUENCE RULE_DOT);

fragment RULE_BINARYEXPONENTPART : ('p' RULE_SIGN? RULE_DIGITSEQUENCE|'P' RULE_SIGN? RULE_DIGITSEQUENCE);

fragment RULE_HEXADECIMALDIGITSEQUENCE : RULE_HEXADECIMALDIGIT+;

fragment RULE_FLOATINGSUFFIX : ('f'|'l'|'F'|'L');

fragment RULE_CHARACTERCONSTANT : (RULE_SINGLEQUOTE RULE_CCHARSEQUENCE RULE_SINGLEQUOTE|'L\'' RULE_CCHARSEQUENCE RULE_SINGLEQUOTE|'u\'' RULE_CCHARSEQUENCE RULE_SINGLEQUOTE|'U\'' RULE_CCHARSEQUENCE RULE_SINGLEQUOTE);

fragment RULE_CCHARSEQUENCE : RULE_CCHAR+;

fragment RULE_CCHAR : (~((RULE_BACKSLASH|RULE_NEWLINE))|RULE_ESCAPESEQUENCE);

fragment RULE_ESCAPESEQUENCE : (RULE_SIMPLEESCAPESEQUENCE|RULE_OCTALESCAPESEQUENCE|RULE_HEXADECIMALESCAPESEQUENCE|RULE_UNIVERSALCHARACTERNAME);

fragment RULE_SIMPLEESCAPESEQUENCE : RULE_BACKSLASH (RULE_SINGLEQUOTE|RULE_DOUBLEQUOTE|'a'|'b'|'f'|'n'|'r'|'t'|'v'|RULE_QUESTION|RULE_BACKSLASH);

fragment RULE_OCTALESCAPESEQUENCE : (RULE_BACKSLASH RULE_OCTALDIGIT|RULE_BACKSLASH RULE_OCTALDIGIT RULE_OCTALDIGIT|RULE_BACKSLASH RULE_OCTALDIGIT RULE_OCTALDIGIT RULE_OCTALDIGIT);

fragment RULE_HEXADECIMALESCAPESEQUENCE : '\\x' RULE_HEXADECIMALDIGIT+;

RULE_STRINGLITERAL : RULE_ENCODINGPREFIX? '"' RULE_SCHARSEQUENCE? '"';

fragment RULE_ENCODINGPREFIX : ('u8'|'u'|'U'|'L');

fragment RULE_SCHARSEQUENCE : RULE_SCHAR+;

fragment RULE_SCHAR : (~(('\n'|'\r'|RULE_BACKSLASH|RULE_DOUBLEQUOTE))|RULE_ESCAPESEQUENCE);

RULE_SINGLEQUOTE : '\'';

RULE_DOUBLEQUOTE : '"';

RULE_BACKSLASH : '\\';

RULE_LINEDIRECTIVE : '#' RULE_WHITESPACE? RULE_DECIMALCONSTANT RULE_WHITESPACE? RULE_STRINGLITERAL ~(RULE_NEWLINE)*;

RULE_PRAGMADIRECTIVE : '#' RULE_WHITESPACE? RULE_PRAGMA RULE_WHITESPACE ~(RULE_NEWLINE)*;

RULE_WHITESPACE : (' '|'\t')+;

RULE_BLOCK_COMMENT : '/*' ( options {greedy=false;} : . )*'*/';

RULE_LINE_COMMENT : '//' ~(RULE_NEWLINE)*;

RULE_NEWLINE : ('\r'|'\n');

RULE_EOF_TERMINAL : EOF;

RULE_ANYOTHER : ~((RULE_COMMA|RULE_LEFTPAREN|RULE_RIGHTPAREN));

RULE_ID : RULE_IDENTIFIER;


